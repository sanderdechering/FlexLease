{"ast":null,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar WebGLKernel = require('../web-gl/kernel');\n\nvar utils = require('../../core/utils');\n\nvar Texture = require('../../core/texture');\n\nvar fragShaderString = require('./shader-frag');\n\nvar vertShaderString = require('./shader-vert');\n\nmodule.exports = function (_WebGLKernel) {\n  _inherits(WebGL2Kernel, _WebGLKernel);\n\n  function WebGL2Kernel() {\n    _classCallCheck(this, WebGL2Kernel);\n\n    return _possibleConstructorReturn(this, (WebGL2Kernel.__proto__ || Object.getPrototypeOf(WebGL2Kernel)).apply(this, arguments));\n  }\n\n  _createClass(WebGL2Kernel, [{\n    key: 'initWebGl',\n    value: function initWebGl() {\n      return utils.initWebGl2(this.getCanvas());\n    }\n    /**\n     * @memberOf WebGL2Kernel#\n     * @function\n     * @name validateOptions\n     *\n     * @desc Validate options related to Kernel, such as\n     * floatOutputs and Textures, texSize, output,\n     * graphical output.\n     *\n     */\n\n  }, {\n    key: 'validateOptions',\n    value: function validateOptions() {\n      var isFloatReadPixel = utils.isFloatReadPixelsSupportedWebGL2();\n\n      if (this.floatOutput === true && this.floatOutputForce !== true && !isFloatReadPixel) {\n        throw new Error('Float texture outputs are not supported on this browser');\n      } else if (this.floatTextures === undefined) {\n        this.floatTextures = true;\n        this.floatOutput = isFloatReadPixel;\n      }\n\n      var hasIntegerDivisionBug = utils.hasIntegerDivisionAccuracyBug();\n\n      if (this.fixIntegerDivisionAccuracy === null) {\n        this.fixIntegerDivisionAccuracy = hasIntegerDivisionBug;\n      } else if (this.fixIntegerDivisionAccuracy && !hasIntegerDivisionBug) {\n        this.fixIntegerDivisionAccuracy = false;\n      }\n\n      utils.checkOutput(this.output);\n\n      if (!this.output || this.output.length === 0) {\n        if (arguments.length !== 1) {\n          throw new Error('Auto output only supported for kernels with only one input');\n        }\n\n        var argType = utils.getArgumentType(arguments[0]);\n\n        if (argType === 'Array') {\n          this.output = utils.getDimensions(argType);\n        } else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {\n          this.output = arguments[0].output;\n        } else {\n          throw new Error('Auto output not supported for input type: ' + argType);\n        }\n      }\n\n      this.texSize = utils.dimToTexSize({\n        floatTextures: this.floatTextures,\n        floatOutput: this.floatOutput\n      }, this.output, true);\n\n      if (this.graphical) {\n        if (this.output.length !== 2) {\n          throw new Error('Output must have 2 dimensions on graphical mode');\n        }\n\n        if (this.floatOutput) {\n          this.floatOutput = false;\n          console.warn('Cannot use graphical mode and float output at the same time');\n        }\n\n        this.texSize = utils.clone(this.output);\n      } else if (this.floatOutput === undefined) {\n        this.floatOutput = true;\n      }\n\n      if (this.floatOutput || this.floatOutputForce) {\n        this._webGl.getExtension('EXT_color_buffer_float');\n      }\n    }\n    /**\n     * @memberOf WebGL2Kernel#\n     * @function\n     * @name run\n     *\n     * @desc Run the kernel program, and send the output to renderOutput\n     *\n     * <p> This method calls a helper method *renderOutput* to return the result. </p>\n     *\n     * @returns {Object|Undefined} Result The final output of the program, as float, and as Textures for reuse.\n     *\n     *\n     */\n\n  }, {\n    key: 'run',\n    value: function run() {\n      if (this.program === null) {\n        this.build.apply(this, arguments);\n      }\n\n      var paramNames = this.paramNames;\n      var paramTypes = this.paramTypes;\n      var texSize = this.texSize;\n      var gl = this._webGl;\n      gl.useProgram(this.program);\n      gl.scissor(0, 0, texSize[0], texSize[1]);\n\n      if (!this.hardcodeConstants) {\n        this.setUniform3iv('uOutputDim', new Int32Array(this.threadDim));\n        this.setUniform2iv('uTexSize', texSize);\n      }\n\n      this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);\n      this.argumentsLength = 0;\n\n      for (var texIndex = 0; texIndex < paramNames.length; texIndex++) {\n        this._addArgument(arguments[texIndex], paramTypes[texIndex], paramNames[texIndex]);\n      }\n\n      if (this.graphical) {\n        if (this.outputToTexture) {\n          gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n\n          if (!this.outputTexture || this.outputImmutable) {\n            this._setupOutputTexture();\n          }\n\n          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n          return new Texture(this.outputTexture, texSize, this.threadDim, this.output, this._webGl, 'ArrayTexture(4)');\n        }\n\n        gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n        return;\n      }\n\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n\n      if (this.outputImmutable) {\n        this._setupOutputTexture();\n      }\n\n      var outputTexture = this.outputTexture;\n\n      if (this.subKernelOutputVariableNames !== null) {\n        if (this.outputImmutable) {\n          this.subKernelOutputTextures = [];\n\n          this._setupSubOutputTextures(this.subKernelOutputVariableNames.length);\n        }\n\n        gl.drawBuffers(this.drawBuffersMap);\n      }\n\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\n      if (this.subKernelOutputTextures !== null) {\n        if (this.subKernels !== null) {\n          var output = [];\n          output.result = this.renderOutput(outputTexture);\n\n          for (var i = 0; i < this.subKernels.length; i++) {\n            output.push(new Texture(this.subKernelOutputTextures[i], texSize, this.threadDim, this.output, this._webGl));\n          }\n\n          return output;\n        } else if (this.subKernelProperties !== null) {\n          var _output = {\n            result: this.renderOutput(outputTexture)\n          };\n          var _i = 0;\n\n          for (var p in this.subKernelProperties) {\n            if (!this.subKernelProperties.hasOwnProperty(p)) continue;\n            _output[p] = new Texture(this.subKernelOutputTextures[_i], texSize, this.threadDim, this.output, this._webGl);\n            _i++;\n          }\n\n          return _output;\n        }\n      }\n\n      return this.renderOutput(outputTexture);\n    }\n    /**\n     * @memberOf WebGL2Kernel#\n     * @function\n     * @name getOutputTexture\n     *\n     * @desc This return defined outputTexture, which is setup in .build(), or if immutable, is defined in .run()\n     *\n     * @returns {Object} Output Texture Cache\n     *\n     */\n\n  }, {\n    key: 'getOutputTexture',\n    value: function getOutputTexture() {\n      return this.outputTexture;\n    }\n    /**\n     * @memberOf WebGL2Kernel#\n     * @function\n     * @name _setupOutputTexture\n     * @private\n     *\n     * @desc Setup and replace output texture\n     */\n\n  }, {\n    key: '_setupOutputTexture',\n    value: function _setupOutputTexture() {\n      var gl = this._webGl;\n      var texSize = this.texSize;\n\n      var texture = this.outputTexture = this._webGl.createTexture();\n\n      gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.paramNames.length);\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n      if (this.floatOutput) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);\n      } else {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      }\n\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    }\n    /**\n     * @memberOf WebGL2Kernel#\n     * @param length\n     * @private\n     *\n     * @desc Setup and replace sub-output textures\n     */\n\n  }, {\n    key: '_setupSubOutputTextures',\n    value: function _setupSubOutputTextures(length) {\n      var gl = this._webGl;\n      var texSize = this.texSize;\n      var drawBuffersMap = this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];\n      var textures = this.subKernelOutputTextures = [];\n\n      for (var i = 0; i < length; i++) {\n        var texture = this._webGl.createTexture();\n\n        textures.push(texture);\n        drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);\n        gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.paramNames.length + i);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n        if (this.floatOutput) {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);\n        } else {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);\n      }\n    }\n    /**\n     * @memberOf WebGL2Kernel#\n     * @function\n     * @name _addArgument\n     *\n     * @desc Adds kernel parameters to the Argument Texture,\n     * binding it to the webGl instance, etc.\n     *\n     * @param {Array|Texture|Number} value - The actual argument supplied to the kernel\n     * @param {String} type - Type of the argument\n     * @param {String} name - Name of the argument\n     *\n     */\n\n  }, {\n    key: '_addArgument',\n    value: function _addArgument(value, type, name) {\n      var gl = this._webGl;\n      var argumentTexture = this.getArgumentTexture(name);\n\n      if (value instanceof Texture) {\n        type = value.type;\n      }\n\n      switch (type) {\n        case 'Array':\n          {\n            var dim = utils.getDimensions(value, true);\n            var size = utils.dimToTexSize({\n              floatTextures: this.floatTextures,\n              floatOutput: this.floatOutput\n            }, dim);\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);\n            gl.bindTexture(gl.TEXTURE_2D, argumentTexture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            var length = size[0] * size[1];\n\n            var _formatArrayTransfer = this._formatArrayTransfer(value, length),\n                valuesFlat = _formatArrayTransfer.valuesFlat,\n                bitRatio = _formatArrayTransfer.bitRatio;\n\n            var buffer = void 0;\n\n            if (this.floatTextures) {\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, size[0], size[1], 0, gl.RGBA, gl.FLOAT, valuesFlat);\n            } else {\n              buffer = new Uint8Array(valuesFlat.buffer);\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size[0] / bitRatio, size[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);\n            }\n\n            if (!this.hardcodeConstants) {\n              this.setUniform3iv('user_' + name + 'Dim', dim);\n              this.setUniform2iv('user_' + name + 'Size', size);\n            }\n\n            this.setUniform1i('user_' + name + 'BitRatio', bitRatio);\n            this.setUniform1i('user_' + name, this.argumentsLength);\n            break;\n          }\n\n        case 'Integer':\n        case 'Float':\n        case 'Number':\n          {\n            this.setUniform1f('user_' + name, value);\n            break;\n          }\n\n        case 'Input':\n          {\n            var input = value;\n            var _dim = input.size;\n\n            var _size = utils.dimToTexSize({\n              floatTextures: this.floatTextures,\n              floatOutput: this.floatOutput\n            }, _dim);\n\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);\n            gl.bindTexture(gl.TEXTURE_2D, argumentTexture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n            var _length = _size[0] * _size[1];\n\n            var _formatArrayTransfer2 = this._formatArrayTransfer(value.value, _length),\n                _valuesFlat = _formatArrayTransfer2.valuesFlat,\n                _bitRatio = _formatArrayTransfer2.bitRatio;\n\n            if (this.floatTextures) {\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, _size[0], _size[1], 0, gl.RGBA, gl.FLOAT, inputArray);\n            } else {\n              var _buffer = new Uint8Array(_valuesFlat.buffer);\n\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _size[0] / _bitRatio, _size[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, _buffer);\n            }\n\n            if (!this.hardcodeConstants) {\n              this.setUniform3iv('user_' + name + 'Dim', _dim);\n              this.setUniform2iv('user_' + name + 'Size', _size);\n            }\n\n            this.setUniform1i('user_' + name + 'BitRatio', _bitRatio);\n            this.setUniform1i('user_' + name, this.argumentsLength);\n            break;\n          }\n\n        case 'HTMLImage':\n          {\n            var inputImage = value;\n            var _dim2 = [inputImage.width, inputImage.height, 1];\n            var _size2 = [inputImage.width, inputImage.height];\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);\n            gl.bindTexture(gl.TEXTURE_2D, argumentTexture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // Upload the image into the texture.\n\n            var mipLevel = 0; // the largest mip\n\n            var internalFormat = gl.RGBA; // format we want in the texture\n\n            var srcFormat = gl.RGBA; // format of data we are supplying\n\n            var srcType = gl.UNSIGNED_BYTE; // type of data we are supplying\n\n            gl.texImage2D(gl.TEXTURE_2D, mipLevel, internalFormat, srcFormat, srcType, inputImage);\n            this.setUniform3iv('user_' + name + 'Dim', _dim2);\n            this.setUniform2iv('user_' + name + 'Size', _size2);\n            this.setUniform1i('user_' + name, this.argumentsLength);\n            break;\n          }\n\n        case 'HTMLImageArray':\n          {\n            var inputImages = value;\n            var _dim3 = [inputImages[0].width, inputImages[0].height, inputImages.length];\n            var _size3 = [inputImages[0].width, inputImages[0].height];\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);\n            gl.bindTexture(gl.TEXTURE_2D_ARRAY, argumentTexture);\n            gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // Upload the images into the texture.\n\n            var _mipLevel = 0; // the largest mip\n\n            var _internalFormat = gl.RGBA; // format we want in the texture\n\n            var width = inputImages[0].width;\n            var height = inputImages[0].height;\n            var textureDepth = inputImages.length;\n            var border = 0;\n            var _srcFormat = gl.RGBA; // format of data we are supplying\n\n            var _srcType = gl.UNSIGNED_BYTE; // type of data we are supplying\n\n            gl.texImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel, _internalFormat, width, height, textureDepth, border, _srcFormat, _srcType, null);\n\n            for (var i = 0; i < inputImages.length; i++) {\n              var xOffset = 0;\n              var yOffset = 0;\n              var imageDepth = 1;\n              gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel, xOffset, yOffset, i, inputImages[i].width, inputImages[i].height, imageDepth, _srcFormat, _srcType, inputImages[i]);\n            }\n\n            this.setUniform3iv('user_' + name + 'Dim', _dim3);\n            this.setUniform2iv('user_' + name + 'Size', _size3);\n            this.setUniform1i('user_' + name, this.argumentsLength);\n            break;\n          }\n\n        case 'ArrayTexture(4)':\n        case 'NumberTexture':\n          {\n            var inputTexture = value;\n            var _dim4 = inputTexture.dimensions;\n            var _size4 = inputTexture.size;\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);\n            gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);\n            this.setUniform3iv('user_' + name + 'Dim', _dim4);\n            this.setUniform2iv('user_' + name + 'Size', _size4);\n            this.setUniform1i('user_' + name + 'BitRatio', 1); // always float32\n\n            this.setUniform1i('user_' + name, this.argumentsLength);\n            break;\n          }\n\n        default:\n          throw new Error('Input type not supported (WebGL): ' + value);\n      }\n\n      this.argumentsLength++;\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getMainConstantsString\n     *\n     */\n\n  }, {\n    key: '_getMainConstantsString',\n    value: function _getMainConstantsString() {\n      var result = [];\n\n      if (this.constants) {\n        for (var name in this.constants) {\n          if (!this.constants.hasOwnProperty(name)) continue;\n          var value = this.constants[name];\n          var type = utils.getArgumentType(value);\n\n          switch (type) {\n            case 'Integer':\n              result.push('const float constants_' + name + ' = ' + parseInt(value) + '.0');\n              break;\n\n            case 'Float':\n              result.push('const float constants_' + name + ' = ' + parseFloat(value));\n              break;\n\n            case 'Array':\n            case 'Input':\n            case 'HTMLImage':\n            case 'ArrayTexture(4)':\n            case 'NumberTexture':\n              result.push('uniform highp sampler2D constants_' + name, 'uniform highp ivec2 constants_' + name + 'Size', 'uniform highp ivec3 constants_' + name + 'Dim', 'uniform highp int constants_' + name + 'BitRatio');\n              break;\n\n            case 'HTMLImageArray':\n              result.push('uniform highp sampler2DArray constants_' + name, 'uniform highp ivec2 constants_' + name + 'Size', 'uniform highp ivec3 constants_' + name + 'Dim', 'uniform highp int constants_' + name + 'BitRatio');\n              break;\n\n            default:\n              throw new Error('Unsupported constant ' + name + ' type ' + type);\n          }\n        }\n      }\n\n      return this._linesToString(result);\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _addConstant\n     *\n     * @desc Adds kernel parameters to the Argument Texture,\n     * binding it to the webGl instance, etc.\n     *\n     * @param {Array|Texture|Number} value - The actual argument supplied to the kernel\n     * @param {String} type - Type of the argument\n     * @param {String} name - Name of the argument\n     *\n     */\n\n  }, {\n    key: '_addConstant',\n    value: function _addConstant(value, type, name) {\n      var gl = this._webGl;\n      var argumentTexture = this.getArgumentTexture(name);\n\n      if (value instanceof Texture) {\n        type = value.type;\n      }\n\n      switch (type) {\n        case 'Array':\n          {\n            var dim = utils.getDimensions(value, true);\n            var size = utils.dimToTexSize({\n              floatTextures: this.floatTextures,\n              floatOutput: this.floatOutput\n            }, dim);\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength);\n            gl.bindTexture(gl.TEXTURE_2D, argumentTexture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            var length = size[0] * size[1];\n\n            var _formatArrayTransfer3 = this._formatArrayTransfer(value, length),\n                valuesFlat = _formatArrayTransfer3.valuesFlat,\n                bitRatio = _formatArrayTransfer3.bitRatio;\n\n            var buffer = void 0;\n\n            if (this.floatTextures) {\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size[0], size[1], 0, gl.RGBA, gl.FLOAT, valuesFlat);\n            } else {\n              buffer = new Uint8Array(valuesFlat.buffer);\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size[0] / bitRatio, size[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);\n            }\n\n            if (!this.hardcodeConstants) {\n              this.setUniform3iv('constants_' + name + 'Dim', dim);\n              this.setUniform2iv('constants_' + name + 'Size', size);\n            }\n\n            this.setUniform1i('constants_' + name + 'BitRatio', bitRatio);\n            this.setUniform1i('constants_' + name, this.constantsLength);\n            break;\n          }\n\n        case 'Input':\n          {\n            var input = value;\n            var _dim5 = input.size;\n\n            var _size5 = utils.dimToTexSize({\n              floatTextures: this.floatTextures,\n              floatOutput: this.floatOutput\n            }, _dim5);\n\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength);\n            gl.bindTexture(gl.TEXTURE_2D, argumentTexture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n            var _length2 = _size5[0] * _size5[1];\n\n            var _formatArrayTransfer4 = this._formatArrayTransfer(value.value, _length2),\n                _valuesFlat2 = _formatArrayTransfer4.valuesFlat,\n                _bitRatio2 = _formatArrayTransfer4.bitRatio;\n\n            if (this.floatTextures) {\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, _size5[0], _size5[1], 0, gl.RGBA, gl.FLOAT, inputArray);\n            } else {\n              var _buffer2 = new Uint8Array(_valuesFlat2.buffer);\n\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _size5[0] / _bitRatio2, _size5[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, _buffer2);\n            }\n\n            if (!this.hardcodeConstants) {\n              this.setUniform3iv('constants_' + name + 'Dim', _dim5);\n              this.setUniform2iv('constants_' + name + 'Size', _size5);\n            }\n\n            this.setUniform1i('constants_' + name + 'BitRatio', _bitRatio2);\n            this.setUniform1i('constants_' + name, this.constantsLength);\n            break;\n          }\n\n        case 'HTMLImage':\n          {\n            var inputImage = value;\n            var _dim6 = [inputImage.width, inputImage.height, 1];\n            var _size6 = [inputImage.width, inputImage.height];\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength);\n            gl.bindTexture(gl.TEXTURE_2D, argumentTexture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // Upload the image into the texture.\n\n            var mipLevel = 0; // the largest mip\n\n            var internalFormat = gl.RGBA; // format we want in the texture\n\n            var srcFormat = gl.RGBA; // format of data we are supplying\n\n            var srcType = gl.UNSIGNED_BYTE; // type of data we are supplying\n\n            gl.texImage2D(gl.TEXTURE_2D, mipLevel, internalFormat, srcFormat, srcType, inputImage);\n            this.setUniform3iv('constants_' + name + 'Dim', _dim6);\n            this.setUniform2iv('constants_' + name + 'Size', _size6);\n            this.setUniform1i('constants_' + name, this.constantsLength);\n            break;\n          }\n\n        case 'HTMLImageArray':\n          {\n            var inputImages = value;\n            var _dim7 = [inputImages[0].width, inputImages[0].height, inputImages.length];\n            var _size7 = [inputImages[0].width, inputImages[0].height];\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength);\n            gl.bindTexture(gl.TEXTURE_2D_ARRAY, argumentTexture);\n            gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // Upload the images into the texture.\n\n            var _mipLevel2 = 0; // the largest mip\n\n            var _internalFormat2 = gl.RGBA; // format we want in the texture\n\n            var width = inputImages[0].width;\n            var height = inputImages[0].height;\n            var textureDepth = inputImages.length;\n            var border = 0;\n            var _srcFormat2 = gl.RGBA; // format of data we are supplying\n\n            var _srcType2 = gl.UNSIGNED_BYTE; // type of data we are supplying\n\n            gl.texImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel2, _internalFormat2, width, height, textureDepth, border, _srcFormat2, _srcType2, null);\n\n            for (var i = 0; i < inputImages.length; i++) {\n              var xOffset = 0;\n              var yOffset = 0;\n              var imageDepth = 1;\n              gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel2, xOffset, yOffset, i, inputImages[i].width, inputImages[i].height, imageDepth, _srcFormat2, _srcType2, inputImages[i]);\n            }\n\n            this.setUniform3iv('constants_' + name + 'Dim', _dim7);\n            this.setUniform2iv('constants_' + name + 'Size', _size7);\n            this.setUniform1i('constants_' + name, this.constantsLength);\n            break;\n          }\n\n        case 'ArrayTexture(4)':\n        case 'NumberTexture':\n          {\n            var inputTexture = value;\n            var _dim8 = inputTexture.dimensions;\n            var _size8 = inputTexture.size;\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength);\n            gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);\n            this.setUniform3iv('constants_' + name + 'Dim', _dim8);\n            this.setUniform2iv('constants_' + name + 'Size', _size8);\n            this.setUniform1i('constants_' + name + 'BitRatio', 1); // aways float32\n\n            this.setUniform1i('constants_' + name, this.constantsLength);\n            break;\n          }\n\n        case 'Integer':\n        case 'Float':\n        default:\n          throw new Error('Input type not supported (WebGL): ' + value);\n      }\n    }\n    /**\n     * @memberOf WebGL2Kernel#\n     * @function\n     * @name _getGetResultString\n     *\n     */\n\n  }, {\n    key: '_getGetResultString',\n    value: function _getGetResultString() {\n      if (!this.floatTextures) {\n        return '  return decode(texel, x, bitRatio);';\n      }\n\n      return '  return texel[channel];';\n    }\n    /**\n     * @memberOf WebGL2Kernel#\n     * @function\n     * @name _getHeaderString\n     *\n     * @desc Get the header string for the program.\n     * This returns an empty string if no sub-kernels are defined.\n     *\n     * @returns {String} result\n     *\n     */\n\n  }, {\n    key: '_getHeaderString',\n    value: function _getHeaderString() {\n      return '';\n    }\n    /**\n     * @memberOf WebGL2Kernel#\n     * @function\n     * @name _getTextureCoordinate\n     *\n     * @desc Get texture coordinate string for the program\n     *\n     * @returns {String} result\n     *\n     */\n\n  }, {\n    key: '_getTextureCoordinate',\n    value: function _getTextureCoordinate() {\n      var names = this.subKernelOutputVariableNames;\n\n      if (names === null || names.length < 1) {\n        return 'in highp vec2 vTexCoord;\\n';\n      } else {\n        return 'out highp vec2 vTexCoord;\\n';\n      }\n    }\n    /**\n     * @memberOf WebGL2Kernel#\n     * @function\n     * @name _getMainParamsString\n     *\n     * @desc Generate transpiled glsl Strings for user-defined parameters sent to a kernel\n     *\n     * @param {Array} args - The actual parameters sent to the Kernel\n     *\n     * @returns {String} result\n     *\n     */\n\n  }, {\n    key: '_getMainParamsString',\n    value: function _getMainParamsString(args) {\n      var result = [];\n      var paramTypes = this.paramTypes;\n      var paramNames = this.paramNames;\n\n      for (var i = 0; i < paramNames.length; i++) {\n        var param = args[i];\n        var paramName = paramNames[i];\n        var paramType = paramTypes[i];\n\n        if (this.hardcodeConstants) {\n          if (paramType === 'Array' || paramType === 'NumberTexture' || paramType === 'ArrayTexture(4)') {\n            var paramDim = utils.getDimensions(param, true);\n            var paramSize = utils.dimToTexSize({\n              floatTextures: this.floatTextures,\n              floatOutput: this.floatOutput\n            }, paramDim);\n            result.push('uniform highp sampler2D user_' + paramName, 'highp ivec2 user_' + paramName + 'Size = ivec2(' + paramSize[0] + ', ' + paramSize[1] + ')', 'highp ivec3 user_' + paramName + 'Dim = ivec3(' + paramDim[0] + ', ' + paramDim[1] + ', ' + paramDim[2] + ')', 'uniform highp int user_' + paramName + 'BitRatio');\n          } else if (paramType === 'Integer') {\n            result.push('highp float user_' + paramName + ' = ' + param + '.0');\n          } else if (paramType === 'Float') {\n            result.push('highp float user_' + paramName + ' = ' + param);\n          }\n        } else {\n          if (paramType === 'Array' || paramType === 'NumberTexture' || paramType === 'ArrayTexture(4)' || paramType === 'Input' || paramType === 'HTMLImage') {\n            result.push('uniform highp sampler2D user_' + paramName, 'uniform highp ivec2 user_' + paramName + 'Size', 'uniform highp ivec3 user_' + paramName + 'Dim');\n\n            if (paramType !== 'HTMLImage') {\n              result.push('uniform highp int user_' + paramName + 'BitRatio');\n            }\n          } else if (paramType === 'HTMLImageArray') {\n            result.push('uniform highp sampler2DArray user_' + paramName, 'uniform highp ivec2 user_' + paramName + 'Size', 'uniform highp ivec3 user_' + paramName + 'Dim');\n          } else if (paramType === 'Integer' || paramType === 'Float') {\n            result.push('uniform float user_' + paramName);\n          }\n        }\n      }\n\n      return this._linesToString(result);\n    }\n    /**\n     * @memberOf WebGL2Kernel#\n     * @function\n     * @name _getKernelString\n     *\n     * @desc Get Kernel program string (in *glsl*) for a kernel.\n     *\n     * @returns {String} result\n     *\n     */\n\n  }, {\n    key: '_getKernelString',\n    value: function _getKernelString() {\n      var result = [];\n      var names = this.subKernelOutputVariableNames;\n\n      if (names !== null) {\n        result.push('float kernelResult = 0.0');\n        result.push('layout(location = 0) out vec4 data0');\n\n        for (var i = 0; i < names.length; i++) {\n          result.push('float ' + names[i] + ' = 0.0', 'layout(location = ' + (i + 1) + ') out vec4 data' + (i + 1));\n        }\n      } else {\n        result.push('out vec4 data0');\n        result.push('float kernelResult = 0.0');\n      }\n\n      return this._linesToString(result) + this.functionBuilder.getPrototypeString('kernel');\n    }\n    /**\n     *\n     * @memberOf WebGL2Kernel#\n     * @function\n     * @name _getMainResultString\n     *\n     * @desc Get main result string with checks for floatOutput, graphical, subKernelsOutputs, etc.\n     *\n     * @returns {String} result\n     *\n     */\n\n  }, {\n    key: '_getMainResultString',\n    value: function _getMainResultString() {\n      var names = this.subKernelOutputVariableNames;\n      var result = [];\n\n      if (this.floatOutput) {\n        result.push('  index *= 4');\n      }\n\n      if (this.graphical) {\n        result.push('  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  data0 = actualColor');\n      } else if (this.floatOutput) {\n        var channels = ['r', 'g', 'b', 'a'];\n\n        for (var i = 0; i < channels.length; ++i) {\n          result.push('  threadId = indexTo3D(index, uOutputDim)');\n          result.push('  kernel()');\n\n          if (names) {\n            result.push('  data0.' + channels[i] + ' = kernelResult');\n\n            for (var j = 0; j < names.length; ++j) {\n              result.push('  data' + (j + 1) + '.' + channels[i] + ' = ' + names[j]);\n            }\n          } else {\n            result.push('  data0.' + channels[i] + ' = kernelResult');\n          }\n\n          if (i < channels.length - 1) {\n            result.push('  index += 1');\n          }\n        }\n      } else if (names !== null) {\n        result.push('  threadId = indexTo3D(index, uOutputDim)');\n        result.push('  kernel()');\n        result.push('  data0 = encode32(kernelResult)');\n\n        for (var _i2 = 0; _i2 < names.length; _i2++) {\n          result.push('  data' + (_i2 + 1) + ' = encode32(' + names[_i2] + ')');\n        }\n      } else {\n        result.push('  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  data0 = encode32(kernelResult)');\n      }\n\n      return this._linesToString(result);\n    }\n    /**\n     * @memberOf WebGL2Kernel#\n     * @function\n     * @name _addKernels\n     *\n     * @desc Adds all the sub-kernels supplied with this Kernel instance.\n     *\n     */\n\n  }, {\n    key: '_addKernels',\n    value: function _addKernels() {\n      var _this2 = this;\n\n      var builder = this.functionBuilder;\n      var gl = this._webGl;\n      builder.addFunctions(this.functions, {\n        constants: this.constants,\n        output: this.output\n      });\n      builder.addNativeFunctions(this.nativeFunctions);\n      builder.addKernel(this.fnString, {\n        prototypeOnly: false,\n        constants: this.constants,\n        output: this.output,\n        debug: this.debug,\n        loopMaxIterations: this.loopMaxIterations,\n        paramNames: this.paramNames,\n        paramTypes: this.paramTypes,\n        constantTypes: this.constantTypes,\n        fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy\n      });\n\n      if (this.subKernels !== null) {\n        this.subKernelOutputTextures = [];\n        this.subKernelOutputVariableNames = [];\n        this.subKernels.forEach(function (subKernel) {\n          return _this2._addSubKernel(subKernel);\n        });\n      } else if (this.subKernelProperties !== null) {\n        this.subKernelOutputTextures = [];\n        this.subKernelOutputVariableNames = [];\n        Object.keys(this.subKernelProperties).forEach(function (property) {\n          return _this2._addSubKernel(_this2.subKernelProperties[property]);\n        });\n      }\n    }\n    /**\n     * @memberOf WebGL2Kernel#\n     * @function\n     * @name _getFragShaderString\n     *\n     * @desc Get the fragment shader String.\n     * If the String hasn't been compiled yet,\n     * then this method compiles it as well\n     *\n     * @param {Array} args - The actual parameters sent to the Kernel\n     *\n     * @returns {string} Fragment Shader string\n     *\n     */\n\n  }, {\n    key: '_getFragShaderString',\n    value: function _getFragShaderString(args) {\n      if (this.compiledFragShaderString !== null) {\n        return this.compiledFragShaderString;\n      }\n\n      return this.compiledFragShaderString = this._replaceArtifacts(this.constructor.fragShaderString, this._getFragShaderArtifactMap(args));\n    }\n    /**\n     * @memberOf WebGL2Kernel#\n     * @function\n     * @name _getVertShaderString\n     *\n     * @desc Get the vertical shader String\n     *\n     * @param {Array} args - The actual parameters sent to the Kernel\n     *\n     * @returns {string} Vertical Shader string\n     *\n     */\n\n  }, {\n    key: '_getVertShaderString',\n    value: function _getVertShaderString(args) {\n      if (this.compiledVertShaderString !== null) {\n        return this.compiledVertShaderString;\n      }\n\n      return this.compiledVertShaderString = this.constructor.vertShaderString;\n    }\n  }], [{\n    key: 'fragShaderString',\n    get: function get() {\n      return fragShaderString;\n    }\n  }, {\n    key: 'vertShaderString',\n    get: function get() {\n      return vertShaderString;\n    }\n  }]);\n\n  return WebGL2Kernel;\n}(WebGLKernel);","map":null,"metadata":{},"sourceType":"script"}