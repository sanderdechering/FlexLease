{"ast":null,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar BaseFunctionNode = require('../function-node-base');\n\nvar utils = require('../../core/utils');\n/**\n * @class CPUFunctionNode\n *\n * @extends BaseFunctionNode#\n *\n * @desc [INTERNAL] Represents a single function, inside JS\n *\n * <p>This handles all the raw state, converted state, etc. Of a single function.</p>\n *\n * @prop functionName         - {String}        Name of the function\n * @prop jsFunction           - {Function}   The JS Function the node represents\n * @prop jsFunctionString     - {String}        jsFunction.toString()\n * @prop paramNames           - {String[]}  Parameter names of the function\n * @prop paramTypes           - {String[]}  Shader land parameters type assumption\n * @prop isRootKernel         - {Boolean}       Special indicator, for kernel function\n * @prop webglFunctionString  - {String}        webgl converted function string\n * @prop openglFunctionString - {String}        opengl converted function string\n * @prop calledFunctions      - {String[]}  List of all the functions called\n * @prop initVariables        - {String[]}  List of variables initialized in the function\n * @prop readVariables        - {String[]}  List of variables read operations occur\n * @prop writeVariables       - {String[]}  List of variables write operations occur\n *\n */\n\n\nmodule.exports = function (_BaseFunctionNode) {\n  _inherits(CPUFunctionNode, _BaseFunctionNode);\n\n  function CPUFunctionNode(functionName, jsFunction, options) {\n    _classCallCheck(this, CPUFunctionNode);\n\n    var _this = _possibleConstructorReturn(this, (CPUFunctionNode.__proto__ || Object.getPrototypeOf(CPUFunctionNode)).call(this, functionName, jsFunction, options));\n\n    _this.paramSizes = options ? options.paramSizes : [];\n    _this.memberStates = [];\n    return _this;\n  }\n\n  _createClass(CPUFunctionNode, [{\n    key: 'pushMemberState',\n    value: function pushMemberState(name) {\n      this.memberStates.push(name);\n    }\n  }, {\n    key: 'popMemberState',\n    value: function popMemberState(name) {\n      if (this.memberState === name) {\n        this.memberStates.pop();\n      } else {\n        throw new Error('Cannot popMemberState ' + name + ' when in ' + this.memberState);\n      }\n    }\n  }, {\n    key: 'generate',\n    value: function generate() {\n      if (this.debug) {\n        console.log(this);\n      }\n\n      this.functionStringArray = this.astGeneric(this.getJsAST(), []);\n      this.functionString = this.functionStringArray.join('').trim();\n      return this.functionString;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name getFunctionPrototypeString\n     *\n     * @desc Returns the converted JS function\n     *\n     * @returns {String} function string, result is cached under this.getFunctionPrototypeString\n     *\n     */\n\n  }, {\n    key: 'getFunctionPrototypeString',\n    value: function getFunctionPrototypeString() {\n      if (this.webGlFunctionPrototypeString) {\n        return this.webGlFunctionPrototypeString;\n      }\n\n      return this.webGlFunctionPrototypeString = this.generate();\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astFunctionDeclaration\n     *\n     * @desc Parses the abstract syntax tree for to its *named function declaration*\n     *\n     * @param {Object} ast - the AST object to parse\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astFunctionDeclaration',\n    value: function astFunctionDeclaration(ast, retArr) {\n      this.builder.addFunction(null, utils.getAstString(this.jsFunctionString, ast));\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astFunctionPrototype\n     *\n     * @desc Parses the abstract syntax tree for to its *named function prototype*\n     *\n     * @param {Object} ast - the AST object to parse\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astFunctionPrototype',\n    value: function astFunctionPrototype(ast, retArr) {\n      // Setup function return type and name\n      if (this.isRootKernel || this.isSubKernel) {\n        return retArr;\n      }\n\n      retArr.push(this.returnType);\n      retArr.push(' ');\n      retArr.push(this.functionName);\n      retArr.push('('); // Arguments handling\n\n      for (var i = 0; i < this.paramNames.length; ++i) {\n        if (i > 0) {\n          retArr.push(', ');\n        }\n\n        retArr.push('user_');\n        retArr.push(this.paramNames[i]);\n      }\n\n      retArr.push(');\\n');\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astFunctionExpression\n     *\n     * @desc Parses the abstract syntax tree for to its *named function*\n     *\n     * @param {Object} ast - the AST object to parse\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astFunctionExpression',\n    value: function astFunctionExpression(ast, retArr) {\n      // Setup function return type and name\n      if (!this.isRootKernel) {\n        retArr.push('function');\n        retArr.push(' ');\n        retArr.push(this.functionName);\n        retArr.push('('); // Arguments handling\n\n        for (var i = 0; i < this.paramNames.length; ++i) {\n          var paramName = this.paramNames[i];\n\n          if (i > 0) {\n            retArr.push(', ');\n          }\n\n          retArr.push('user_');\n          retArr.push(paramName);\n        } // Function opening\n\n\n        retArr.push(') {\\n');\n      } // Body statement iteration\n\n\n      for (var _i = 0; _i < ast.body.body.length; ++_i) {\n        this.astGeneric(ast.body.body[_i], retArr);\n        retArr.push('\\n');\n      }\n\n      if (!this.isRootKernel) {\n        // Function closing\n        retArr.push('}\\n');\n      }\n\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astReturnStatement\n     *\n     * @desc Parses the abstract syntax tree for to *return* statement\n     *\n     * @param {Object} ast - the AST object to parse\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astReturnStatement',\n    value: function astReturnStatement(ast, retArr) {\n      if (this.isRootKernel) {\n        retArr.push('kernelResult = ');\n        this.astGeneric(ast.argument, retArr);\n        retArr.push(';');\n      } else if (this.isSubKernel) {\n        retArr.push(this.functionName + 'Result = ');\n        this.astGeneric(ast.argument, retArr);\n        retArr.push(';');\n        retArr.push('return ' + this.functionName + 'Result;');\n      } else {\n        retArr.push('return ');\n        this.astGeneric(ast.argument, retArr);\n        retArr.push(';');\n      } //throw this.astErrorOutput(\n      //\t'Non main function return, is not supported : '+this.currentFunctionNamespace,\n      //\tast\n      //);\n\n\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astLiteral\n     *\n     * @desc Parses the abstract syntax tree for *literal value*\n     *\n     * @param {Object} ast - the AST object to parse\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astLiteral',\n    value: function astLiteral(ast, retArr) {\n      // Reject non numeric literals\n      if (isNaN(ast.value)) {\n        throw this.astErrorOutput('Non-numeric literal not supported : ' + ast.value, ast);\n      }\n\n      retArr.push(ast.value);\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astBinaryExpression\n     *\n     * @desc Parses the abstract syntax tree for *binary* expression\n     *\n     * @param {Object} ast - the AST object to parse\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astBinaryExpression',\n    value: function astBinaryExpression(ast, retArr) {\n      retArr.push('(');\n      this.astGeneric(ast.left, retArr);\n      retArr.push(ast.operator);\n      this.astGeneric(ast.right, retArr);\n      retArr.push(')');\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astIdentifierExpression\n     *\n     * @desc Parses the abstract syntax tree for *identifier* expression\n     *\n     * @param {Object} idtNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astIdentifierExpression',\n    value: function astIdentifierExpression(idtNode, retArr) {\n      if (idtNode.type !== 'Identifier') {\n        throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);\n      }\n\n      switch (this.state) {\n        case 'input-index-y':\n        case 'input-index-z':\n          retArr.push('(');\n      }\n\n      switch (idtNode.name) {\n        case 'gpu_threadX':\n          retArr.push('threadId.x');\n          break;\n\n        case 'gpu_threadY':\n          retArr.push('threadId.y');\n          break;\n\n        case 'gpu_threadZ':\n          retArr.push('threadId.z');\n          break;\n\n        case 'gpu_outputX':\n          retArr.push('uOutputDim.x');\n          break;\n\n        case 'gpu_outputY':\n          retArr.push('uOutputDim.y');\n          break;\n\n        case 'gpu_outputZ':\n          retArr.push('uOutputDim.z');\n          break;\n\n        case 'Infinity':\n          retArr.push('Infinity');\n          break;\n\n        default:\n          if (this.constants && this.constants.hasOwnProperty(idtNode.name)) {\n            retArr.push('constants_' + idtNode.name);\n          } else {\n            var userParamName = this.getUserParamName(idtNode.name);\n\n            if (userParamName !== null) {\n              retArr.push('user_' + userParamName);\n            } else {\n              retArr.push('user_' + idtNode.name);\n            }\n          }\n\n      }\n\n      switch (this.state) {\n        case 'input-index-y':\n          {\n            var size = this.paramSizes[this.paramNames.indexOf(this.memberState)];\n            retArr.push(' * ' + size[0] + ')');\n            break;\n          }\n\n        case 'input-index-z':\n          {\n            var _size = this.paramSizes[this.paramNames.indexOf(this.memberState)];\n            retArr.push(' * ' + _size[0] * _size[1] + ')');\n            break;\n          }\n      }\n\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astForStatement\n     *\n     * @desc Parses the abstract syntax tree forfor *for-loop* expression\n     *\n     * @param {Object} forNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the parsed cpu string\n     */\n\n  }, {\n    key: 'astForStatement',\n    value: function astForStatement(forNode, retArr) {\n      if (forNode.type !== 'ForStatement') {\n        throw this.astErrorOutput('Invalid for statement', forNode);\n      }\n\n      if (forNode.test && forNode.test.type === 'BinaryExpression') {\n        if ((forNode.test.right.type === 'Identifier' || forNode.test.right.type === 'Literal') && forNode.test.operator === '<' && this.isIdentifierConstant(forNode.test.right.name) === false) {\n          if (!this.loopMaxIterations) {\n            console.warn('Warning: loopMaxIterations is not set! Using default of 1000 which may result in unintended behavior.');\n            console.warn('Set loopMaxIterations or use a for loop of fixed length to silence this message.');\n          }\n\n          retArr.push('for (');\n          this.astGeneric(forNode.init, retArr);\n\n          if (retArr[retArr.length - 1] !== ';') {\n            retArr.push(';');\n          }\n\n          this.astGeneric(forNode.test.left, retArr);\n          retArr.push(forNode.test.operator);\n          retArr.push('LOOP_MAX');\n          retArr.push(';');\n          this.astGeneric(forNode.update, retArr);\n          retArr.push(')');\n          retArr.push('{\\n');\n          retArr.push('if (');\n          this.astGeneric(forNode.test.left, retArr);\n          retArr.push(forNode.test.operator);\n          this.astGeneric(forNode.test.right, retArr);\n          retArr.push(') {\\n');\n\n          if (forNode.body.type === 'BlockStatement') {\n            for (var i = 0; i < forNode.body.body.length; i++) {\n              this.astGeneric(forNode.body.body[i], retArr);\n            }\n          } else {\n            this.astGeneric(forNode.body, retArr);\n          }\n\n          retArr.push('} else {\\n');\n          retArr.push('break;\\n');\n          retArr.push('}\\n');\n          retArr.push('}\\n');\n          return retArr;\n        } else if (forNode.init.declarations) {\n          var declarations = JSON.parse(JSON.stringify(forNode.init.declarations));\n          var updateArgument = forNode.update.argument;\n\n          if (!Array.isArray(declarations) || declarations.length < 1) {\n            console.log(this.jsFunctionString);\n            throw new Error('Error: Incompatible for loop declaration');\n          }\n\n          if (declarations.length > 1) {\n            var initArgument = null;\n\n            for (var _i2 = 0; _i2 < declarations.length; _i2++) {\n              var declaration = declarations[_i2];\n\n              if (declaration.id.name === updateArgument.name) {\n                initArgument = declaration;\n                declarations.splice(_i2, 1);\n              } else {\n                retArr.push('var ');\n                this.astGeneric(declaration, retArr);\n                retArr.push(';');\n              }\n            }\n\n            retArr.push('for (let ');\n            this.astGeneric(initArgument, retArr);\n            retArr.push(';');\n          } else {\n            retArr.push('for (');\n            this.astGeneric(forNode.init, retArr);\n          }\n\n          this.astGeneric(forNode.test, retArr);\n          retArr.push(';');\n          this.astGeneric(forNode.update, retArr);\n          retArr.push(')');\n          this.astGeneric(forNode.body, retArr);\n          return retArr;\n        }\n      }\n\n      throw this.astErrorOutput('Invalid for statement', forNode);\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astWhileStatement\n     *\n     * @desc Parses the abstract syntax tree for *while* loop\n     *\n     *\n     * @param {Object} whileNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the parsed openclgl string\n     */\n\n  }, {\n    key: 'astWhileStatement',\n    value: function astWhileStatement(whileNode, retArr) {\n      if (whileNode.type !== 'WhileStatement') {\n        throw this.astErrorOutput('Invalid while statement', whileNode);\n      }\n\n      retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');\n      retArr.push('if (');\n      this.astGeneric(whileNode.test, retArr);\n      retArr.push(') {\\n');\n      this.astGeneric(whileNode.body, retArr);\n      retArr.push('} else {\\n');\n      retArr.push('break;\\n');\n      retArr.push('}\\n');\n      retArr.push('}\\n');\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astWhileStatement\n     *\n     * @desc Parses the abstract syntax tree for *do while* loop\n     *\n     *\n     * @param {Object} doWhileNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the parsed webgl string\n     */\n\n  }, {\n    key: 'astDoWhileStatement',\n    value: function astDoWhileStatement(doWhileNode, retArr) {\n      if (doWhileNode.type !== 'DoWhileStatement') {\n        throw this.astErrorOutput('Invalid while statement', doWhileNode);\n      }\n\n      retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');\n      this.astGeneric(doWhileNode.body, retArr);\n      retArr.push('if (!');\n      this.astGeneric(doWhileNode.test, retArr);\n      retArr.push(') {\\n');\n      retArr.push('break;\\n');\n      retArr.push('}\\n');\n      retArr.push('}\\n');\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astAssignmentExpression\n     *\n     * @desc Parses the abstract syntax tree for *Assignment* Expression\n     *\n     * @param {Object} assNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astAssignmentExpression',\n    value: function astAssignmentExpression(assNode, retArr) {\n      this.astGeneric(assNode.left, retArr);\n      retArr.push(assNode.operator);\n      this.astGeneric(assNode.right, retArr);\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astEmptyStatement\n     *\n     * @desc Parses the abstract syntax tree for an *Empty* Statement\n     *\n     * @param {Object} eNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astEmptyStatement',\n    value: function astEmptyStatement(eNode, retArr) {\n      //retArr.push(';\\n');\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astBlockStatement\n     *\n     * @desc Parses the abstract syntax tree for *Block* statement\n     *\n     * @param {Object} bNode - the AST object to parse\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astBlockStatement',\n    value: function astBlockStatement(bNode, retArr) {\n      retArr.push('{\\n');\n\n      for (var i = 0; i < bNode.body.length; i++) {\n        this.astGeneric(bNode.body[i], retArr);\n      }\n\n      retArr.push('}\\n');\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astExpressionStatement\n     *\n     * @desc Parses the abstract syntax tree for *generic expression* statement\n     *\n     * @param {Object} esNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astExpressionStatement',\n    value: function astExpressionStatement(esNode, retArr) {\n      this.astGeneric(esNode.expression, retArr);\n      retArr.push(';');\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astVariableDeclaration\n     *\n     * @desc Parses the abstract syntax tree for *Variable Declaration*\n     *\n     * @param {Object} vardecNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astVariableDeclaration',\n    value: function astVariableDeclaration(vardecNode, retArr) {\n      retArr.push('var ');\n\n      for (var i = 0; i < vardecNode.declarations.length; i++) {\n        this.declarations[vardecNode.declarations[i].id.name] = 'var';\n\n        if (i > 0) {\n          retArr.push(',');\n        }\n\n        this.astGeneric(vardecNode.declarations[i], retArr);\n      }\n\n      retArr.push(';');\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astVariableDeclarator\n     *\n     * @desc Parses the abstract syntax tree for *Variable Declarator*\n     *\n     * @param {Object} ivardecNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astVariableDeclarator',\n    value: function astVariableDeclarator(ivardecNode, retArr) {\n      this.astGeneric(ivardecNode.id, retArr);\n\n      if (ivardecNode.init !== null) {\n        retArr.push('=');\n        this.astGeneric(ivardecNode.init, retArr);\n      }\n\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astIfStatement\n     *\n     * @desc Parses the abstract syntax tree for *If* Statement\n     *\n     * @param {Object} ifNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astIfStatement',\n    value: function astIfStatement(ifNode, retArr) {\n      retArr.push('if (');\n      this.astGeneric(ifNode.test, retArr);\n      retArr.push(')');\n\n      if (ifNode.consequent.type === 'BlockStatement') {\n        this.astGeneric(ifNode.consequent, retArr);\n      } else {\n        retArr.push(' {\\n');\n        this.astGeneric(ifNode.consequent, retArr);\n        retArr.push('\\n}\\n');\n      }\n\n      if (ifNode.alternate) {\n        retArr.push('else ');\n\n        if (ifNode.alternate.type === 'BlockStatement') {\n          this.astGeneric(ifNode.alternate, retArr);\n        } else {\n          retArr.push(' {\\n');\n          this.astGeneric(ifNode.alternate, retArr);\n          retArr.push('\\n}\\n');\n        }\n      }\n\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astBreakStatement\n     *\n     * @desc Parses the abstract syntax tree for *Break* Statement\n     *\n     * @param {Object} brNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astBreakStatement',\n    value: function astBreakStatement(brNode, retArr) {\n      retArr.push('break;\\n');\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astContinueStatement\n     *\n     * @desc Parses the abstract syntax tree for *Continue* Statement\n     *\n     * @param {Object} crNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astContinueStatement',\n    value: function astContinueStatement(crNode, retArr) {\n      retArr.push('continue;\\n');\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astLogicalExpression\n     *\n     * @desc Parses the abstract syntax tree for *Logical* Expression\n     *\n     * @param {Object} logNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astLogicalExpression',\n    value: function astLogicalExpression(logNode, retArr) {\n      retArr.push('(');\n      this.astGeneric(logNode.left, retArr);\n      retArr.push(logNode.operator);\n      this.astGeneric(logNode.right, retArr);\n      retArr.push(')');\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astUpdateExpression\n     *\n     * @desc Parses the abstract syntax tree for *Update* Expression\n     *\n     * @param {Object} uNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astUpdateExpression',\n    value: function astUpdateExpression(uNode, retArr) {\n      if (uNode.prefix) {\n        retArr.push(uNode.operator);\n        this.astGeneric(uNode.argument, retArr);\n      } else {\n        this.astGeneric(uNode.argument, retArr);\n        retArr.push(uNode.operator);\n      }\n\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astUnaryExpression\n     *\n     * @desc Parses the abstract syntax tree for *Unary* Expression\n     *\n     * @param {Object} uNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astUnaryExpression',\n    value: function astUnaryExpression(uNode, retArr) {\n      if (uNode.prefix) {\n        retArr.push(uNode.operator);\n        this.astGeneric(uNode.argument, retArr);\n      } else {\n        this.astGeneric(uNode.argument, retArr);\n        retArr.push(uNode.operator);\n      }\n\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astThisExpression\n     *\n     * @desc Parses the abstract syntax tree for *This* expression\n     *\n     * @param {Object} tNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astThisExpression',\n    value: function astThisExpression(tNode, retArr) {\n      retArr.push('_this');\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astMemberExpression\n     *\n     * @desc Parses the abstract syntax tree for *Member* Expression\n     *\n     * @param {Object} mNode - An ast Node\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astMemberExpression',\n    value: function astMemberExpression(mNode, retArr) {\n      if (mNode.computed) {\n        if (mNode.object.type === 'Identifier' || mNode.object.type === 'MemberExpression' && mNode.object.object.object && mNode.object.object.object.type === 'ThisExpression' && mNode.object.object.property.name === 'constants') {\n          this.pushState('identifier');\n          this.astGeneric(mNode.object, retArr);\n          this.popState('identifier');\n          retArr.push('[');\n\n          if (this.isInput(mNode.object.name)) {\n            this.astGeneric(mNode.property, retArr);\n          } else {\n            this.astGeneric(mNode.property, retArr);\n          }\n\n          retArr.push(']');\n        } else {\n          if (mNode.object.object) {\n            if (mNode.object.object.object && this.isInput(mNode.object.object.object.name)) {\n              this.pushMemberState(mNode.object.object.object.name);\n              this.pushState('input-index-z');\n              this.astGeneric(mNode.object, retArr);\n              var last = retArr.pop();\n              retArr.push(' + ');\n              this.popState('input-index-z');\n              this.pushState('input-index');\n              this.astGeneric(mNode.property, retArr);\n              this.popState('input-index');\n              retArr.push(last);\n              this.popMemberState(mNode.object.object.object.name);\n            } else if (this.isInput(mNode.object.object.name)) {\n              this.pushMemberState(mNode.object.object.name);\n\n              if (!this.isState('input-index-z')) {\n                this.pushState('input-index-y');\n              }\n\n              this.astGeneric(mNode.object, retArr);\n\n              var _last = retArr.pop();\n\n              retArr.push(' + ');\n\n              if (!this.isState('input-index-z')) {\n                this.popState('input-index-y');\n              }\n\n              var isInputIndexZ = this.isState('input-index-z');\n\n              if (isInputIndexZ) {\n                this.pushState('input-index-y');\n              } else {\n                this.pushState('input-index');\n              }\n\n              this.astGeneric(mNode.property, retArr);\n\n              if (isInputIndexZ) {\n                this.popState('input-index-y');\n              } else {\n                this.popState('input-index');\n              }\n\n              retArr.push(_last);\n              this.popMemberState(mNode.object.object.name);\n            } else {\n              this.astGeneric(mNode.object, retArr);\n\n              var _last2 = retArr.pop();\n\n              retArr.push('][');\n              this.astGeneric(mNode.property, retArr);\n              retArr.push(_last2);\n            }\n          } else {\n            this.astGeneric(mNode.object, retArr);\n\n            var _last3 = retArr.pop();\n\n            retArr.push('][');\n            this.astGeneric(mNode.property, retArr);\n            retArr.push(_last3);\n          }\n        }\n      } else {\n        var unrolled = this.astMemberExpressionUnroll(mNode);\n\n        if (mNode.property.type === 'Identifier' && mNode.computed) {\n          unrolled = 'user_' + unrolled;\n        }\n\n        if (unrolled.indexOf('this.constants') === 0) {\n          // remove 'this.constants' from beginning\n          unrolled = 'constants_' + unrolled.substring(15);\n        } else if (unrolled.indexOf('this') === 0) {\n          // Its a reference to `this`, add '_' before\n          unrolled = '_' + unrolled;\n        }\n\n        switch (this.state) {\n          case 'input-index-y':\n          case 'input-index-z':\n            retArr.push('(');\n        }\n\n        switch (unrolled) {\n          case '_this.output.x':\n            retArr.push(this.output[0]);\n            break;\n\n          case '_this.output.y':\n            retArr.push(this.output[1]);\n            break;\n\n          case '_this.output.z':\n            retArr.push(this.output[2]);\n            break;\n\n          default:\n            if (mNode.object && mNode.object.name && this.declarations[mNode.object.name]) {\n              retArr.push('user_');\n            }\n\n            retArr.push(unrolled);\n        }\n\n        switch (this.state) {\n          case 'input-index-y':\n            {\n              var size = this.paramSizes[this.paramNames.indexOf(this.memberState)];\n              retArr.push(' * ' + size[0] + ')');\n              break;\n            }\n\n          case 'input-index-z':\n            {\n              var _size2 = this.paramSizes[this.paramNames.indexOf(this.memberState)];\n              retArr.push(' * ' + _size2[0] * _size2[1] + ')');\n              break;\n            }\n        }\n      }\n\n      return retArr;\n    }\n  }, {\n    key: 'astSequenceExpression',\n    value: function astSequenceExpression(sNode, retArr) {\n      for (var i = 0; i < sNode.expressions.length; i++) {\n        if (i > 0) {\n          retArr.push(',');\n        }\n\n        this.astGeneric(sNode.expressions, retArr);\n      }\n\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astCallExpression\n     *\n     * @desc Parses the abstract syntax tree for *call* expression\n     *\n     * @param {Object} ast - the AST object to parse\n     * @param {Array} retArr - return array string\n     *\n     * @returns  {Array} the append retArr\n     */\n\n  }, {\n    key: 'astCallExpression',\n    value: function astCallExpression(ast, retArr) {\n      if (ast.callee) {\n        // Get the full function call, unrolled\n        var funcName = this.astMemberExpressionUnroll(ast.callee); // Register the function into the called registry\n\n        if (this.calledFunctions.indexOf(funcName) < 0) {\n          this.calledFunctions.push(funcName);\n        }\n\n        if (!this.hasOwnProperty('funcName')) {\n          this.calledFunctionsArguments[funcName] = [];\n        }\n\n        var functionArguments = [];\n        this.calledFunctionsArguments[funcName].push(functionArguments); // Call the function\n\n        retArr.push(funcName); // Open arguments space\n\n        retArr.push('('); // Add the vars\n\n        for (var i = 0; i < ast.arguments.length; ++i) {\n          var argument = ast.arguments[i];\n\n          if (i > 0) {\n            retArr.push(', ');\n          }\n\n          this.astGeneric(argument, retArr);\n\n          if (argument.type === 'Identifier') {\n            var paramIndex = this.paramNames.indexOf(argument.name);\n\n            if (paramIndex === -1) {\n              functionArguments.push(null);\n            } else {\n              functionArguments.push({\n                name: argument.name,\n                type: this.paramTypes[paramIndex]\n              });\n            }\n          } else {\n            functionArguments.push(null);\n          }\n        } // Close arguments space\n\n\n        retArr.push(')');\n        return retArr;\n      } // Failure, unknown expression\n\n\n      throw this.astErrorOutput('Unknown CallExpression', ast);\n      return retArr;\n    }\n    /**\n     * @memberOf CPUFunctionNode#\n     * @function\n     * @name astArrayExpression\n     *\n     * @desc Parses the abstract syntax tree for *Array* Expression\n     *\n     * @param {Object} arrNode - the AST object to parse\n     * @param {Array} retArr - return array string\n     *\n     * @returns {Array} the append retArr\n     */\n\n  }, {\n    key: 'astArrayExpression',\n    value: function astArrayExpression(arrNode, retArr) {\n      var arrLen = arrNode.elements.length;\n      retArr.push('[');\n\n      for (var i = 0; i < arrLen; ++i) {\n        if (i > 0) {\n          retArr.push(', ');\n        }\n\n        var subNode = arrNode.elements[i];\n        this.astGeneric(subNode, retArr);\n      }\n\n      retArr.push(']');\n      return retArr; // // Failure, unknown expression\n      // throw this.astErrorOutput(\n      // \t'Unknown  ArrayExpression',\n      // \tarrNode\n      //);\n    }\n  }, {\n    key: 'astDebuggerStatement',\n    value: function astDebuggerStatement(arrNode, retArr) {\n      retArr.push('debugger;');\n      return retArr;\n    }\n  }, {\n    key: 'memberState',\n    get: function get() {\n      return this.memberStates[this.memberStates.length - 1];\n    }\n  }]);\n\n  return CPUFunctionNode;\n}(BaseFunctionNode);","map":null,"metadata":{},"sourceType":"script"}