{"ast":null,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar utils = require('./utils');\n\nvar WebGLRunner = require('../backend/web-gl/runner');\n\nvar WebGL2Runner = require('../backend/web-gl2/runner');\n\nvar CPURunner = require('../backend/cpu/runner');\n\nvar WebGLValidatorKernel = require('../backend/web-gl/validator-kernel');\n\nvar WebGL2ValidatorKernel = require('../backend/web-gl2/validator-kernel');\n\nvar GPUCore = require(\"./gpu-core\");\n/**\n * Initialises the GPU.js library class which manages the webGlContext for the created functions.\n * @class\n * @extends GPUCore\n */\n\n\nvar GPU = function (_GPUCore) {\n  _inherits(GPU, _GPUCore);\n  /**\n   * Creates an instance of GPU.\n   * @param {any} settings - Settings to set mode, andother properties. See #GPUCore\n   * @memberOf GPU#\n   */\n\n\n  function GPU(settings) {\n    _classCallCheck(this, GPU);\n\n    var _this = _possibleConstructorReturn(this, (GPU.__proto__ || Object.getPrototypeOf(GPU)).call(this, settings));\n\n    settings = settings || {};\n    _this._canvas = settings.canvas || null;\n    _this._webGl = settings.webGl || null;\n    var mode = settings.mode;\n    var detectedMode = void 0;\n\n    if (!utils.isWebGlSupported()) {\n      if (mode && mode !== 'cpu') {\n        throw new Error('A requested mode of \"' + mode + '\" and is not supported');\n      } else {\n        console.warn('Warning: gpu not supported, falling back to cpu support');\n        detectedMode = 'cpu';\n      }\n    } else {\n      if (_this._webGl) {\n        if (typeof WebGL2RenderingContext !== 'undefined' && _this._webGl.constructor === WebGL2RenderingContext) {\n          detectedMode = 'webgl2';\n        } else if (typeof WebGLRenderingContext !== 'undefined' && _this._webGl.constructor === WebGLRenderingContext) {\n          detectedMode = 'webgl';\n        } else {\n          throw new Error('unknown WebGL Context');\n        }\n      } else {\n        detectedMode = mode || 'gpu';\n      }\n    }\n\n    _this.kernels = [];\n    var runnerSettings = {\n      canvas: _this._canvas,\n      webGl: _this._webGl\n    };\n\n    switch (detectedMode) {\n      // public options\n      case 'cpu':\n        _this._runner = new CPURunner(runnerSettings);\n        break;\n\n      case 'gpu':\n        var Runner = _this.getGPURunner();\n\n        _this._runner = new Runner(runnerSettings);\n        break;\n      // private explicit options for testing\n\n      case 'webgl2':\n        _this._runner = new WebGL2Runner(runnerSettings);\n        break;\n\n      case 'webgl':\n        _this._runner = new WebGLRunner(runnerSettings);\n        break;\n      // private explicit options for internal\n\n      case 'webgl2-validator':\n        _this._runner = new WebGL2Runner(runnerSettings);\n        _this._runner.Kernel = WebGL2ValidatorKernel;\n        break;\n\n      case 'webgl-validator':\n        _this._runner = new WebGLRunner(runnerSettings);\n        _this._runner.Kernel = WebGLValidatorKernel;\n        break;\n\n      default:\n        throw new Error('\"' + mode + '\" mode is not defined');\n    }\n\n    return _this;\n  }\n  /**\n   *\n   * This creates a callable function object to call the kernel function with the argument parameter set\n   *\n   * @name createKernel\n   * @function\n   * @memberOf GPU##\n   *\n   * @param {Function} fn - The calling to perform the conversion\n   * @param {Object} [settings] - The parameter configuration object\n   * @property {String} settings.dimensions - Thread dimension array (Defaults to [1024])\n   * @property {String} settings.mode - CPU / GPU configuration mode (Defaults to null)\n   *\n   * The following modes are supported\n   * *'falsey'* : Attempts to build GPU mode, else fallbacks\n   * *'gpu'* : Attempts to build GPU mode, else fallbacks\n   * *'cpu'* : Forces JS fallback mode only\n   *\n   *\n   * @returns {Function} callable function to run\n   *\n   */\n\n\n  _createClass(GPU, [{\n    key: 'createKernel',\n    value: function createKernel(fn, settings) {\n      //\n      // basic parameters safety checks\n      //\n      if (typeof fn === 'undefined') {\n        throw 'Missing fn parameter';\n      }\n\n      if (!utils.isFunction(fn) && typeof fn !== 'string') {\n        throw 'fn parameter not a function';\n      }\n\n      var mergedSettings = Object.assign({\n        webGl: this._webGl,\n        canvas: this._canvas\n      }, settings || {});\n\n      var kernel = this._runner.buildKernel(fn, mergedSettings); //if canvas didn't come from this, propagate from kernel\n\n\n      if (!this._canvas) {\n        this._canvas = kernel.getCanvas();\n      }\n\n      if (!this._runner.canvas) {\n        this._runner.canvas = kernel.getCanvas();\n      }\n\n      this.kernels.push(kernel);\n      return kernel;\n    }\n    /**\n     *\n     * Create a super kernel which executes sub kernels\n     * and saves their output to be used with the next sub kernel.\n     * This can be useful if we want to save the output on one kernel,\n     * and then use it as an input to another kernel. *Machine Learning*\n     *\n     * @name createKernelMap\n     * @function\n     * @memberOf GPU#\n     *\n     * @param {Object|Array} subKernels - Sub kernels for this kernel\n     * @param {Function} rootKernel - Root kernel\n     *\n     * @returns {Function} callable kernel function\n     *\n     * @example\n     * const megaKernel = gpu.createKernelMap({\n     *   addResult: function add(a, b) {\n     *     return a[this.thread.x] + b[this.thread.x];\n     *   },\n     *   multiplyResult: function multiply(a, b) {\n     *     return a[this.thread.x] * b[this.thread.x];\n     *   },\n     *  }, function(a, b, c) {\n     *       return multiply(add(a, b), c);\n     * });\n     *\n     * megaKernel(a, b, c);\n     *\n     * Note: You can also define subKernels as an array of functions.\n     * > [add, multiply]\n     *\n     */\n\n  }, {\n    key: 'createKernelMap',\n    value: function createKernelMap() {\n      var fn = void 0;\n      var settings = void 0;\n\n      if (typeof arguments[arguments.length - 2] === 'function') {\n        fn = arguments[arguments.length - 2];\n        settings = arguments[arguments.length - 1];\n      } else {\n        fn = arguments[arguments.length - 1];\n      }\n\n      if (!utils.isWebGlDrawBuffersSupported()) {\n        this._runner = new CPURunner(settings);\n      }\n\n      var kernel = this.createKernel(fn, settings);\n\n      if (Array.isArray(arguments[0])) {\n        var functions = arguments[0];\n\n        for (var i = 0; i < functions.length; i++) {\n          kernel.addSubKernel(functions[i]);\n        }\n      } else {\n        var _functions = arguments[0];\n\n        for (var p in _functions) {\n          if (!_functions.hasOwnProperty(p)) continue;\n          kernel.addSubKernelProperty(p, _functions[p]);\n        }\n      }\n\n      return kernel;\n    }\n    /**\n     *\n     * Combine different kernels into one super Kernel,\n     * useful to perform multiple operations inside one\n     * kernel without the penalty of data transfer between\n     * cpu and gpu.\n     *\n     * The number of kernel functions sent to this method can be variable.\n     * You can send in one, two, etc.\n     *\n     * @name combineKernels\n     * @function\n     * @memberOf GPU#\n     *\n     * @param {Function} subKernels - Kernel function(s) to combine.\n     * @param {Function} rootKernel - Root kernel to combine kernels into\n     *\n     * @example\n     * \tcombineKernels(add, multiply, function(a,b,c){\n     *\t \treturn add(multiply(a,b), c)\n     *\t})\n     *\n     * @returns {Function} Callable kernel function\n     *\n     */\n\n  }, {\n    key: 'combineKernels',\n    value: function combineKernels() {\n      var lastKernel = arguments[arguments.length - 2];\n      var combinedKernel = arguments[arguments.length - 1];\n      if (this.getMode() === 'cpu') return combinedKernel;\n      var canvas = arguments[0].getCanvas();\n      var webGl = arguments[0].getWebGl();\n\n      for (var i = 0; i < arguments.length - 1; i++) {\n        arguments[i].setCanvas(canvas).setWebGl(webGl).setOutputToTexture(true);\n      }\n\n      return function () {\n        combinedKernel.apply(null, arguments);\n        var texSize = lastKernel.texSize;\n        var gl = lastKernel.getWebGl();\n        var threadDim = lastKernel.threadDim;\n        var result = void 0;\n\n        if (lastKernel.floatOutput) {\n          var w = texSize[0];\n          var h = Math.ceil(texSize[1] / 4);\n          result = new Float32Array(w * h * 4);\n          gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);\n        } else {\n          var bytes = new Uint8Array(texSize[0] * texSize[1] * 4);\n          gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, bytes);\n          result = new Float32Array(bytes.buffer);\n        }\n\n        result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);\n\n        if (lastKernel.output.length === 1) {\n          return result;\n        } else if (lastKernel.output.length === 2) {\n          return utils.splitArray(result, lastKernel.output[0]);\n        } else if (lastKernel.output.length === 3) {\n          var cube = utils.splitArray(result, lastKernel.output[0] * lastKernel.output[1]);\n          return cube.map(function (x) {\n            return utils.splitArray(x, lastKernel.output[0]);\n          });\n        }\n      };\n    }\n  }, {\n    key: 'getGPURunner',\n    value: function getGPURunner() {\n      if (typeof WebGL2RenderingContext !== 'undefined' && utils.isWebGl2Supported()) return WebGL2Runner;\n      if (typeof WebGLRenderingContext !== 'undefined') return WebGLRunner;\n    }\n    /**\n     *\n     * Adds additional functions, that the kernel may call.\n     *\n     * @name addFunction\n     * @function\n     * @memberOf GPU#\n     *\n     * @param {Function|String} fn - JS Function to do conversion\n     * @param {Object} options\n     *\n     * @returns {GPU} returns itself\n     *\n     */\n\n  }, {\n    key: 'addFunction',\n    value: function addFunction(fn, options) {\n      this._runner.functionBuilder.addFunction(null, fn, options);\n\n      return this;\n    }\n    /**\n     *\n     * Adds additional native functions, that the kernel may call.\n     *\n     * @name addNativeFunction\n     * @function\n     * @memberOf GPU#\n     *\n     * @param {String} name - native function name, used for reverse lookup\n     * @param {String} nativeFunction - the native function implementation, as it would be defined in it's entirety\n     *\n     * @returns {GPU} returns itself\n     *\n     */\n\n  }, {\n    key: 'addNativeFunction',\n    value: function addNativeFunction(name, nativeFunction) {\n      this._runner.functionBuilder.addNativeFunction(name, nativeFunction);\n\n      return this;\n    }\n    /**\n     *\n     * Return the current mode in which gpu.js is executing.\n     * @name getMode\n     * @function\n     * @memberOf GPU#\n     *\n     * @returns {String} The current mode, \"cpu\", \"webgl\", etc.\n     *\n     */\n\n  }, {\n    key: 'getMode',\n    value: function getMode() {\n      return this._runner.getMode();\n    }\n    /**\n     *\n     * Return TRUE, if browser supports WebGl AND Canvas\n     *\n     * @name get isWebGlSupported\n     * @function\n     * @memberOf GPU#\n     *\n     * Note: This function can also be called directly `GPU.isWebGlSupported()`\n     *\n     * @returns {Boolean} TRUE if browser supports webGl\n     *\n     */\n\n  }, {\n    key: 'isWebGlSupported',\n    value: function isWebGlSupported() {\n      return utils.isWebGlSupported();\n    }\n    /**\n     *\n     * Return TRUE, if system has integer division accuracy issue\n     *\n     * @name get hasIntegerDivisionAccuracyBug\n     * @function\n     * @memberOf GPU#\n     *\n     * Note: This function can also be called directly `GPU.hasIntegerDivisionAccuracyBug()`\n     *\n     * @returns {Boolean} TRUE if system has integer division accuracy issue\n     *\n     *\n     */\n\n  }, {\n    key: 'hasIntegerDivisionAccuracyBug',\n    value: function hasIntegerDivisionAccuracyBug() {\n      return utils.hasIntegerDivisionAccuracyBug();\n    }\n    /**\n     *\n     * Return the canvas object bound to this gpu instance.\n     *\n     * @name getCanvas\n     * @function\n     * @memberOf GPU#\n     *\n     * @returns {Object} Canvas object if present\n     *\n     */\n\n  }, {\n    key: 'getCanvas',\n    value: function getCanvas() {\n      return this._canvas;\n    }\n    /**\n     *\n     * Return the webGl object bound to this gpu instance.\n     *\n     * @name getWebGl\n     * @function\n     * @memberOf GPU#\n     *\n     * @returns {Object} WebGl object if present\n     *\n     */\n\n  }, {\n    key: 'getWebGl',\n    value: function getWebGl() {\n      return this._webGl;\n    }\n    /**\n     *\n     * Destroys all memory associated with gpu.js & the webGl if we created it\n     *\n     * @name destroy\n     * @function\n     * @memberOf GPU#\n     *\n     *\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      var _this2 = this; // perform on next runloop - for some reason we dont get lose context events \n      // if webGl is created and destroyed in the same run loop.\n\n\n      setTimeout(function () {\n        var kernels = _this2.kernels;\n        var destroyWebGl = !_this2._webGl && kernels.length && kernels[0]._webGl;\n\n        for (var i = 0; i < _this2.kernels.length; i++) {\n          _this2.kernels[i].destroy(true); // remove canvas if exists\n\n        }\n\n        if (destroyWebGl) {\n          destroyWebGl.OES_texture_float = null;\n          destroyWebGl.OES_texture_float_linear = null;\n          destroyWebGl.OES_element_index_uint = null;\n          var loseContextExt = destroyWebGl.getExtension('WEBGL_lose_context');\n\n          if (loseContextExt) {\n            loseContextExt.loseContext();\n          }\n        }\n      }, 0);\n    }\n  }]);\n\n  return GPU;\n}(GPUCore);\n\n; // This ensure static methods are \"inherited\"\n// See: https://stackoverflow.com/questions/5441508/how-to-inherit-static-methods-from-base-class-in-javascript\n\nObject.assign(GPU, GPUCore);\nmodule.exports = GPU;","map":null,"metadata":{},"sourceType":"script"}