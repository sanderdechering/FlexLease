{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _matrix = require('./matrix');\n\nvar _matrix2 = _interopRequireDefault(_matrix);\n\nvar _randomMatrix = require('./matrix/random-matrix');\n\nvar _randomMatrix2 = _interopRequireDefault(_randomMatrix);\n\nvar _equation = require('./matrix/equation');\n\nvar _equation2 = _interopRequireDefault(_equation);\n\nvar _rnn = require('./rnn');\n\nvar _rnn2 = _interopRequireDefault(_rnn);\n\nvar _zeros = require('../utilities/zeros');\n\nvar _zeros2 = _interopRequireDefault(_zeros);\n\nvar _softmax = require('./matrix/softmax');\n\nvar _softmax2 = _interopRequireDefault(_softmax);\n\nvar _random = require('../utilities/random');\n\nvar _sampleI = require('./matrix/sample-i');\n\nvar _sampleI2 = _interopRequireDefault(_sampleI);\n\nvar _maxI = require('./matrix/max-i');\n\nvar _maxI2 = _interopRequireDefault(_maxI);\n\nvar _lookup = require('../lookup');\n\nvar _lookup2 = _interopRequireDefault(_lookup);\n\nvar _lookupTable2 = require('../utilities/lookup-table');\n\nvar _lookupTable3 = _interopRequireDefault(_lookupTable2);\n\nvar _arrayLookupTable = require('../utilities/array-lookup-table');\n\nvar _arrayLookupTable2 = _interopRequireDefault(_arrayLookupTable);\n\nvar _cast = require('../utilities/cast');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar RNNTimeStep = function (_RNN) {\n  _inherits(RNNTimeStep, _RNN);\n\n  function RNNTimeStep() {\n    _classCallCheck(this, RNNTimeStep);\n\n    return _possibleConstructorReturn(this, (RNNTimeStep.__proto__ || Object.getPrototypeOf(RNNTimeStep)).apply(this, arguments));\n  }\n\n  _createClass(RNNTimeStep, [{\n    key: 'createOutputMatrix',\n    value: function createOutputMatrix() {\n      var model = this.model;\n      var outputSize = this.outputSize;\n      var lastHiddenSize = this.hiddenLayers[this.hiddenLayers.length - 1]; //whd\n\n      model.outputConnector = new _randomMatrix2.default(outputSize, lastHiddenSize, 0.08); //bd\n\n      model.output = new _randomMatrix2.default(outputSize, 1, 0.08);\n    }\n  }, {\n    key: 'bindEquation',\n    value: function bindEquation() {\n      var model = this.model;\n      var hiddenLayers = this.hiddenLayers;\n      var layers = model.hiddenLayers;\n      var equation = new _equation2.default();\n      var outputs = [];\n      var equationConnection = model.equationConnections.length > 0 ? model.equationConnections[model.equationConnections.length - 1] : this.initialLayerInputs; // 0 index\n\n      var output = this.getEquation(equation, equation.input(new _matrix2.default(this.inputSize, 1)), equationConnection[0], layers[0]);\n      outputs.push(output); // 1+ indices\n\n      for (var i = 1, max = hiddenLayers.length; i < max; i++) {\n        output = this.getEquation(equation, output, equationConnection[i], layers[i]);\n        outputs.push(output);\n      }\n\n      model.equationConnections.push(outputs);\n      equation.add(equation.multiply(model.outputConnector, output), model.output);\n      model.equations.push(equation);\n    }\n  }, {\n    key: 'mapModel',\n    value: function mapModel() {\n      var model = this.model;\n      var hiddenLayers = model.hiddenLayers;\n      var allMatrices = model.allMatrices;\n      this.initialLayerInputs = this.hiddenLayers.map(function (size) {\n        return new _matrix2.default(size, 1);\n      });\n      this.createHiddenLayers();\n      if (!model.hiddenLayers.length) throw new Error('net.hiddenLayers not set');\n\n      for (var i = 0, max = hiddenLayers.length; i < max; i++) {\n        var hiddenMatrix = hiddenLayers[i];\n\n        for (var property in hiddenMatrix) {\n          if (!hiddenMatrix.hasOwnProperty(property)) continue;\n          allMatrices.push(hiddenMatrix[property]);\n        }\n      }\n\n      this.createOutputMatrix();\n      if (!model.outputConnector) throw new Error('net.model.outputConnector not set');\n      if (!model.output) throw new Error('net.model.output not set');\n      allMatrices.push(model.outputConnector);\n      allMatrices.push(model.output);\n    }\n  }, {\n    key: 'backpropagate',\n    value: function backpropagate() {\n      for (var i = this.model.equations.length - 1; i > -1; i--) {\n        this.model.equations[i].backpropagate();\n      }\n    }\n    /**\n     *\n     * @param {number[]|number[][]|object|object[][]} [rawInput]\n     * @returns {number[]|number|object|object[]|object[][]}\n     */\n\n  }, {\n    key: 'run',\n    value: function run(rawInput) {\n      if (this.inputSize === 1) {\n        if (this.outputLookup) {\n          this.run = this.runObject;\n          return this.runObject(rawInput);\n        }\n\n        this.run = this.runNumbers;\n        return this.runNumbers(rawInput);\n      }\n\n      this.run = this.runArrays;\n      return this.runArrays(rawInput);\n    }\n  }, {\n    key: 'forecast',\n    value: function forecast(input, count) {\n      if (this.inputSize === 1) {\n        if (this.outputLookup) {\n          this.forecast = this.runObject;\n          return this.runObject(input);\n        }\n\n        this.forecast = this.forecastNumbers;\n        return this.forecastNumbers(input, count);\n      }\n\n      if (this.outputLookup) {\n        this.forecast = this.forecastObjects;\n        return this.forecastObjects(input, count);\n      }\n\n      this.forecast = this.forecastArrays;\n      return this.forecastArrays(input, count);\n    }\n    /**\n     *\n     * @param {Object[]|String[]} data an array of objects: `{input: 'string', output: 'string'}` or an array of strings\n     * @param {Object} [options]\n     * @returns {{error: number, iterations: number}}\n     */\n\n  }, {\n    key: 'train',\n    value: function train(data) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.trainOpts = options = Object.assign({}, this.constructor.trainDefaults, options);\n      var iterations = options.iterations;\n      var errorThresh = options.errorThresh;\n      var log = options.log === true ? console.log : options.log;\n      var logPeriod = options.logPeriod;\n      var callback = options.callback;\n      var callbackPeriod = options.callbackPeriod;\n\n      if (this.inputSize === 1 || !this.inputSize) {\n        this.setSize(data);\n      }\n\n      data = this.formatData(data);\n      var error = Infinity;\n      var i = void 0;\n      this.verifyIsInitialized(data);\n\n      for (i = 0; i < iterations && error > errorThresh; i++) {\n        var sum = 0;\n\n        for (var j = 0; j < data.length; j++) {\n          var err = this.trainPattern(data[j], true);\n          sum += err;\n        }\n\n        error = sum / data.length;\n        if (isNaN(error)) throw new Error('network error rate is unexpected NaN, check network configurations and try again');\n\n        if (log && i % logPeriod === 0) {\n          log('iterations: ' + i + ', training error: ' + error);\n        }\n\n        if (callback && i % callbackPeriod === 0) {\n          callback({\n            error: error,\n            iterations: i\n          });\n        }\n      }\n\n      return {\n        error: error,\n        iterations: i\n      };\n    }\n    /**\n     *\n     * @param data\n     * Verifies network sizes are initialized\n     * If they are not it will initialize them based off the data set.\n     */\n\n  }, {\n    key: 'verifyIsInitialized',\n    value: function verifyIsInitialized(data) {\n      if (data[0].input) {\n        this.trainInput = this.trainInputOutput;\n      } else if (data[0].length > 0) {\n        if (data[0][0].length > 0) {\n          this.trainInput = this.trainArrays;\n        } else {\n          if (this.inputSize > 1) {\n            this.trainInput = this.trainArrays;\n          } else {\n            this.trainInput = this.trainNumbers;\n          }\n        }\n      }\n\n      if (!this.model) {\n        this.initialize();\n      }\n    }\n  }, {\n    key: 'setSize',\n    value: function setSize(data) {\n      var dataShape = _lookup2.default.dataShape(data).join(',');\n\n      switch (dataShape) {\n        case 'array,array,number':\n        case 'array,object,number':\n        case 'array,datum,array,number':\n        case 'array,datum,object,number':\n          // probably 1\n          break;\n\n        case 'array,array,array,number':\n          this.inputSize = this.outputSize = data[0][0].length;\n          break;\n\n        case 'array,array,object,number':\n          this.inputSize = this.outputSize = Object.keys(_lookup2.default.toTable2D(data)).length;\n          break;\n\n        case 'array,datum,array,array,number':\n          this.inputSize = this.outputSize = data[0].input[0].length;\n          break;\n\n        case 'array,datum,array,object,number':\n          this.inputSize = Object.keys(_lookup2.default.toInputTable2D(data)).length;\n          this.outputSize = Object.keys(_lookup2.default.toOutputTable2D(data)).length;\n          break;\n\n        default:\n          throw new Error('unknown data shape or configuration');\n      }\n    }\n  }, {\n    key: 'trainNumbers',\n    value: function trainNumbers(input) {\n      var model = this.model;\n      var equations = model.equations;\n\n      while (equations.length < input.length) {\n        this.bindEquation();\n      }\n\n      var errorSum = 0;\n\n      for (var i = 0, max = input.length - 1; i < max; i++) {\n        errorSum += equations[i].predictTarget(input[i], input[i + 1]);\n      }\n\n      this.end();\n      return errorSum / input.length;\n    }\n  }, {\n    key: 'runNumbers',\n    value: function runNumbers(input) {\n      if (!this.isRunnable) return null;\n      var model = this.model;\n      var equations = model.equations;\n\n      if (this.inputLookup) {\n        input = _lookup2.default.toArray(this.inputLookup, input, this.inputLookupLength);\n      }\n\n      while (equations.length <= input.length) {\n        this.bindEquation();\n      }\n\n      var lastOutput = void 0;\n\n      for (var i = 0; i < input.length; i++) {\n        lastOutput = equations[i].runInput([input[i]]);\n      }\n\n      this.end();\n      return lastOutput.weights[0];\n    }\n  }, {\n    key: 'forecastNumbers',\n    value: function forecastNumbers(input, count) {\n      if (!this.isRunnable) return null;\n      var model = this.model;\n      var equations = model.equations;\n      var length = input.length + count;\n\n      while (equations.length <= length) {\n        this.bindEquation();\n      }\n\n      var lastOutput = void 0;\n      var equationIndex = 0;\n\n      for (var i = 0; i < input.length; i++) {\n        lastOutput = equations[equationIndex++].runInput([input[i]]);\n      }\n\n      var result = [lastOutput.weights[0]];\n\n      for (var _i = 0, max = count - 1; _i < max; _i++) {\n        lastOutput = equations[equationIndex++].runInput(lastOutput.weights);\n        result.push(lastOutput.weights[0]);\n      }\n\n      this.end();\n      return result;\n    }\n  }, {\n    key: 'runObject',\n    value: function runObject(input) {\n      if (this.inputLookup === this.outputLookup) {\n        var inputArray = _lookup2.default.toArrayShort(this.inputLookup, input);\n\n        return _lookup2.default.toObjectPartial(this.outputLookup, this.forecastNumbers(inputArray, this.outputLookupLength - inputArray.length), inputArray.length);\n      }\n\n      return _lookup2.default.toObject(this.outputLookup, this.forecastNumbers(_lookup2.default.toArray(this.inputLookup, input, this.inputLookupLength), this.outputLookupLength));\n    }\n  }, {\n    key: 'forecastObjects',\n    value: function forecastObjects(input, count) {\n      var _this2 = this;\n\n      input = input.map(function (value) {\n        return _lookup2.default.toArray(_this2.outputLookup, value, _this2.outputLookupLength);\n      });\n      return this.forecastArrays(input, count).map(function (value) {\n        return _lookup2.default.toObject(_this2.outputLookup, value);\n      });\n    }\n  }, {\n    key: 'trainInputOutput',\n    value: function trainInputOutput(object) {\n      var model = this.model;\n      var input = object.input;\n      var output = object.output;\n      var totalSize = input.length + output.length;\n      var equations = model.equations;\n\n      while (equations.length < totalSize) {\n        this.bindEquation();\n      }\n\n      var errorSum = 0;\n      var equationIndex = 0;\n\n      for (var inputIndex = 0, max = input.length - 1; inputIndex < max; inputIndex++) {\n        errorSum += equations[equationIndex++].predictTarget(input[inputIndex], input[inputIndex + 1]);\n      }\n\n      errorSum += equations[equationIndex++].predictTarget(input[input.length - 1], output[0]);\n\n      for (var outputIndex = 0, _max = output.length - 1; outputIndex < _max; outputIndex++) {\n        errorSum += equations[equationIndex++].predictTarget(output[outputIndex], output[outputIndex + 1]);\n      }\n\n      this.end();\n      return errorSum / totalSize;\n    }\n  }, {\n    key: 'trainArrays',\n    value: function trainArrays(input) {\n      var model = this.model;\n      var equations = model.equations;\n\n      while (equations.length < input.length) {\n        this.bindEquation();\n      }\n\n      var errorSum = 0;\n\n      for (var i = 0, max = input.length - 1; i < max; i++) {\n        errorSum += equations[i].predictTarget(input[i], input[i + 1]);\n      }\n\n      this.end();\n      return errorSum / input.length;\n    }\n  }, {\n    key: 'runArrays',\n    value: function runArrays(input) {\n      if (!this.isRunnable) return null;\n      var model = this.model;\n      var equations = model.equations;\n\n      while (equations.length <= input.length) {\n        this.bindEquation();\n      }\n\n      if (this.inputLookup) {\n        input = _lookup2.default.toArrays(this.inputLookup, input, this.inputLookupLength);\n      }\n\n      var lastOutput = void 0;\n\n      for (var i = 0; i < input.length; i++) {\n        var outputMatrix = equations[i].runInput(input[i]);\n        lastOutput = outputMatrix.weights;\n      }\n\n      this.end();\n\n      if (this.outputLookup) {\n        return _lookup2.default.toObject(this.outputLookup, lastOutput);\n      }\n\n      return lastOutput;\n    }\n  }, {\n    key: 'forecastArrays',\n    value: function forecastArrays(input, count) {\n      if (!this.isRunnable) return null;\n      var model = this.model;\n      var equations = model.equations;\n      var length = input.length + count;\n\n      while (equations.length <= length) {\n        this.bindEquation();\n      }\n\n      var lastOutput = void 0;\n      var equationIndex = 0;\n\n      for (var i = 0; i < input.length; i++) {\n        lastOutput = equations[equationIndex++].runInput(input[i]);\n      }\n\n      var result = [lastOutput.weights];\n\n      for (var _i2 = 0, max = count - 1; _i2 < max; _i2++) {\n        lastOutput = equations[equationIndex++].runInput(lastOutput.weights);\n        result.push(lastOutput.weights.slice(0));\n      }\n\n      this.end();\n      return result;\n    }\n  }, {\n    key: 'end',\n    value: function end() {\n      this.model.equations[this.model.equations.length - 1].runInput(new Float32Array(this.outputSize));\n    }\n    /**\n     *\n     * @param data\n     * @returns {*}\n     */\n\n  }, {\n    key: 'formatData',\n    value: function formatData(data) {\n      var dataShape = _lookup2.default.dataShape(data).join(',');\n\n      var result = [];\n\n      switch (dataShape) {\n        case 'array,number':\n          {\n            if (this.inputSize !== 1) {\n              throw new Error('inputSize must be 1 for this data size');\n            }\n\n            if (this.outputSize !== 1) {\n              throw new Error('outputSize must be 1 for this data size');\n            }\n\n            for (var i = 0; i < data.length; i++) {\n              result.push(Float32Array.from([data[i]]));\n            }\n\n            return [result];\n          }\n\n        case 'array,array,number':\n          {\n            if (this.inputSize === 1 && this.outputSize === 1) {\n              for (var _i3 = 0; _i3 < data.length; _i3++) {\n                result.push((0, _cast.arrayToFloat32Arrays)(data[_i3]));\n              }\n\n              return result;\n            }\n\n            if (this.inputSize !== data[0].length) {\n              throw new Error('inputSize must match data input size');\n            }\n\n            if (this.outputSize !== data[0].length) {\n              throw new Error('outputSize must match data input size');\n            }\n\n            for (var _i4 = 0; _i4 < data.length; _i4++) {\n              result.push(Float32Array.from(data[_i4]));\n            }\n\n            return [result];\n          }\n\n        case 'array,object,number':\n          {\n            if (this.inputSize !== 1) {\n              throw new Error('inputSize must be 1 for this data size');\n            }\n\n            if (this.outputSize !== 1) {\n              throw new Error('outputSize must be 1 for this data size');\n            }\n\n            if (!this.inputLookup) {\n              var lookupTable = new _lookupTable3.default(data);\n              this.inputLookup = this.outputLookup = lookupTable.table;\n              this.inputLookupLength = this.outputLookupLength = lookupTable.length;\n            }\n\n            for (var _i5 = 0; _i5 < data.length; _i5++) {\n              result.push((0, _cast.objectToFloat32Arrays)(data[_i5]));\n            }\n\n            return result;\n          }\n\n        case 'array,datum,array,number':\n          {\n            if (this.inputSize !== 1) {\n              throw new Error('inputSize must be 1 for this data size');\n            }\n\n            if (this.outputSize !== 1) {\n              throw new Error('outputSize must be 1 for this data size');\n            }\n\n            for (var _i6 = 0; _i6 < data.length; _i6++) {\n              var datum = data[_i6];\n              result.push({\n                input: (0, _cast.arrayToFloat32Arrays)(datum.input),\n                output: (0, _cast.arrayToFloat32Arrays)(datum.output)\n              });\n            }\n\n            return result;\n          }\n\n        case 'array,datum,object,number':\n          {\n            if (this.inputSize !== 1) {\n              throw new Error('inputSize must be 1 for this data size');\n            }\n\n            if (this.outputSize !== 1) {\n              throw new Error('outputSize must be 1 for this data size');\n            }\n\n            if (!this.inputLookup) {\n              var inputLookup = new _lookupTable3.default(data, 'input');\n              this.inputLookup = inputLookup.table;\n              this.inputLookupLength = inputLookup.length;\n            }\n\n            if (!this.outputLookup) {\n              var outputLookup = new _lookupTable3.default(data, 'output');\n              this.outputLookup = outputLookup.table;\n              this.outputLookupLength = outputLookup.length;\n            }\n\n            for (var _i7 = 0; _i7 < data.length; _i7++) {\n              var _datum = data[_i7];\n              result.push({\n                input: (0, _cast.objectToFloat32Arrays)(_datum.input),\n                output: (0, _cast.objectToFloat32Arrays)(_datum.output)\n              });\n            }\n\n            return result;\n          }\n\n        case 'array,array,array,number':\n          {\n            for (var _i8 = 0; _i8 < data.length; _i8++) {\n              result.push((0, _cast.arraysToFloat32Arrays)(data[_i8]));\n            }\n\n            return result;\n          }\n\n        case 'array,array,object,number':\n          {\n            if (!this.inputLookup) {\n              var _lookupTable = new _lookupTable3.default(data);\n\n              this.inputLookup = this.outputLookup = _lookupTable.table;\n              this.inputLookupLength = this.outputLookupLength = _lookupTable.length;\n            }\n\n            for (var _i9 = 0; _i9 < data.length; _i9++) {\n              var array = [];\n\n              for (var j = 0; j < data[_i9].length; j++) {\n                array.push((0, _cast.objectToFloat32Array)(data[_i9][j], this.inputLookup, this.inputLookupLength));\n              }\n\n              result.push(array);\n            }\n\n            return result;\n          }\n\n        case 'array,datum,array,array,number':\n          {\n            if (this.inputSize === 1 && this.outputSize === 1) {\n              for (var _i10 = 0; _i10 < data.length; _i10++) {\n                var _datum2 = data[_i10];\n                result.push({\n                  input: Float32Array.from(_datum2.input),\n                  output: Float32Array.from(_datum2.output)\n                });\n              }\n            } else {\n              if (this.inputSize !== data[0].input[0].length) {\n                throw new Error('inputSize must match data input size');\n              }\n\n              if (this.outputSize !== data[0].output[0].length) {\n                throw new Error('outputSize must match data output size');\n              }\n\n              for (var _i11 = 0; _i11 < data.length; _i11++) {\n                var _datum3 = data[_i11];\n                result.push({\n                  input: (0, _cast.arraysToFloat32Arrays)(_datum3.input),\n                  output: (0, _cast.arraysToFloat32Arrays)(_datum3.output)\n                });\n              }\n            }\n\n            return result;\n          }\n\n        case 'array,datum,array,object,number':\n          {\n            if (!this.inputLookup) {\n              var _inputLookup = new _arrayLookupTable2.default(data, 'input');\n\n              this.inputLookup = _inputLookup.table;\n              this.inputLookupLength = _inputLookup.length;\n            }\n\n            if (!this.outputLookup) {\n              var _outputLookup = new _arrayLookupTable2.default(data, 'output');\n\n              this.outputLookup = _outputLookup.table;\n              this.outputLookupLength = _outputLookup.length;\n            }\n\n            for (var _i12 = 0; _i12 < data.length; _i12++) {\n              var _datum4 = data[_i12];\n              result.push({\n                input: (0, _cast.objectsToFloat32Arrays)(_datum4.input, this.inputLookup, this.inputLookupLength),\n                output: (0, _cast.objectsToFloat32Arrays)(_datum4.output, this.outputLookup, this.outputLookupLength)\n              });\n            }\n\n            return result;\n          }\n\n        default:\n          throw new Error('unknown data shape or configuration');\n      }\n    }\n    /**\n     *\n     * @param data\n     * @returns {\n     *  {\n     *    error: number,\n     *    misclasses: Array\n     *  }\n     * }\n     */\n\n  }, {\n    key: 'test',\n    value: function test(data) {\n      var formattedData = this.formatData(data); // for classification problems\n\n      var misclasses = []; // run each pattern through the trained network and collect\n      // error and misclassification statistics\n\n      var errorSum = 0;\n\n      var dataShape = _lookup2.default.dataShape(data).join(',');\n\n      switch (dataShape) {\n        case 'array,array,number':\n          {\n            if (this.inputSize === 1) {\n              for (var i = 0; i < formattedData.length; i++) {\n                var input = formattedData[i];\n                var output = this.run(input.splice(0, input.length - 1));\n                var target = input[input.length - 1][0];\n                var error = target - output;\n                var errorMSE = error * error;\n                errorSum += errorMSE;\n                var errorsAbs = Math.abs(errorMSE);\n\n                if (errorsAbs > this.trainOpts.errorThresh) {\n                  var misclass = data[i];\n                  Object.assign(misclass, {\n                    value: input,\n                    actual: output\n                  });\n                  misclasses.push(misclass);\n                }\n              }\n\n              break;\n            }\n\n            throw new Error('unknown data shape or configuration');\n          }\n\n        case 'array,array,array,number':\n          {\n            for (var _i13 = 0; _i13 < formattedData.length; _i13++) {\n              var _input = formattedData[_i13];\n\n              var _output = this.run(_input.splice(0, _input.length - 1));\n\n              var _target = _input[_input.length - 1];\n              var errors = 0;\n              var errorCount = 0;\n\n              for (var j = 0; j < _output.length; j++) {\n                errorCount++;\n\n                var _error = _target[j] - _output[j]; // mse\n\n\n                errors += _error * _error;\n              }\n\n              errorSum += errors / errorCount;\n\n              var _errorsAbs = Math.abs(errors);\n\n              if (_errorsAbs > this.trainOpts.errorThresh) {\n                var _misclass = data[_i13];\n                misclasses.push({\n                  value: _misclass,\n                  actual: _output\n                });\n              }\n            }\n\n            break;\n          }\n\n        case 'array,object,number':\n          {\n            for (var _i14 = 0; _i14 < formattedData.length; _i14++) {\n              var _input2 = formattedData[_i14];\n\n              var _output2 = this.run(_lookup2.default.toObjectPartial(this.outputLookup, _input2, 0, _input2.length - 1));\n\n              var _target2 = _input2[_input2.length - 1];\n              var _errors = 0;\n              var p = void 0;\n\n              for (p in _output2) {}\n\n              var _error2 = _target2[_i14] - _output2[p]; // mse\n\n\n              _errors += _error2 * _error2;\n              errorSum += _errors;\n\n              var _errorsAbs2 = Math.abs(_errors);\n\n              if (_errorsAbs2 > this.trainOpts.errorThresh) {\n                var _misclass2 = data[_i14];\n                misclasses.push({\n                  value: _misclass2,\n                  actual: _output2\n                });\n              }\n            }\n\n            break;\n          }\n\n        case 'array,array,object,number':\n          {\n            for (var _i15 = 0; _i15 < formattedData.length; _i15++) {\n              var _input3 = formattedData[_i15];\n\n              var _output3 = this.run(_input3.slice(0, _input3.length - 1));\n\n              var _target3 = data[_i15][_input3.length - 1];\n              var _errors2 = 0;\n              var _errorCount = 0;\n\n              for (var _p in _output3) {\n                var _error3 = _target3[_p] - _output3[_p]; // mse\n\n\n                _errors2 += _error3 * _error3;\n                _errorCount++;\n              }\n\n              errorSum += _errors2 / _errorCount;\n\n              var _errorsAbs3 = Math.abs(_errors2);\n\n              if (_errorsAbs3 > this.trainOpts.errorThresh) {\n                var _misclass3 = data[_i15];\n                misclasses.push({\n                  value: _misclass3,\n                  actual: _output3\n                });\n              }\n            }\n\n            break;\n          }\n\n        case 'array,datum,array,number':\n        case 'array,datum,object,number':\n          {\n            for (var _i16 = 0; _i16 < formattedData.length; _i16++) {\n              var datum = formattedData[_i16];\n\n              var _output4 = this.forecast(datum.input, datum.output.length);\n\n              var _errors3 = 0;\n              var _errorCount2 = 0;\n\n              for (var _j = 0; _j < _output4.length; _j++) {\n                var _error4 = datum.output[_j][0] - _output4[_j];\n\n                _errors3 += _error4 * _error4;\n                _errorCount2++;\n              }\n\n              errorSum += _errors3 / _errorCount2;\n\n              var _errorsAbs4 = Math.abs(_errors3);\n\n              if (_errorsAbs4 > this.trainOpts.errorThresh) {\n                var _misclass4 = data[_i16];\n                Object.assign(_misclass4, {\n                  actual: this.outputLookup ? _lookup2.default.toObject(this.outputLookup, _output4) : _output4\n                });\n                misclasses.push(_misclass4);\n              }\n            }\n\n            break;\n          }\n\n        case 'array,datum,array,array,number':\n          {\n            for (var _i17 = 0; _i17 < formattedData.length; _i17++) {\n              var _datum5 = formattedData[_i17];\n\n              var _output5 = this.forecast(_datum5.input, _datum5.output.length);\n\n              var _errors4 = 0;\n\n              for (var _j2 = 0; _j2 < _output5.length; _j2++) {\n                for (var k = 0; k < _output5[_j2].length; k++) {\n                  var _error5 = _datum5.output[_j2][k] - _output5[_j2][k];\n\n                  _errors4 += _error5 * _error5;\n                }\n              }\n\n              errorSum += _errors4;\n\n              var _errorsAbs5 = Math.abs(_errors4);\n\n              if (_errorsAbs5 > this.trainOpts.errorThresh) {\n                var _misclass5 = data[_i17];\n                misclasses.push({\n                  input: _misclass5.input,\n                  output: _misclass5.output,\n                  actual: _output5\n                });\n              }\n            }\n\n            break;\n          }\n\n        case 'array,datum,array,object,number':\n          {\n            for (var _i18 = 0; _i18 < formattedData.length; _i18++) {\n              var _datum6 = formattedData[_i18];\n\n              var _output6 = this.forecast(_datum6.input, _datum6.output.length);\n\n              var _errors5 = 0;\n\n              for (var _j3 = 0; _j3 < _output6.length; _j3++) {\n                for (var _p2 in _output6[_j3]) {\n                  var _error6 = data[_i18].output[_j3][_p2] - _output6[_j3][_p2];\n\n                  _errors5 += _error6 * _error6;\n                }\n              }\n\n              errorSum += _errors5;\n\n              var _errorsAbs6 = Math.abs(_errors5);\n\n              if (_errorsAbs6 > this.trainOpts.errorThresh) {\n                var _misclass6 = data[_i18];\n                misclasses.push({\n                  input: _misclass6.input,\n                  output: _misclass6.output,\n                  actual: _output6\n                });\n              }\n            }\n\n            break;\n          }\n\n        default:\n          throw new Error('unknown data shape or configuration');\n      }\n\n      return {\n        error: errorSum / formattedData.length,\n        misclasses: misclasses,\n        total: formattedData.length\n      };\n    }\n  }, {\n    key: 'addFormat',\n    value: function addFormat(value) {\n      var dataShape = _lookup2.default.dataShape(value).join(',');\n\n      switch (dataShape) {\n        case 'array,array,number':\n        case 'datum,array,array,number':\n        case 'array,number':\n        case 'datum,array,number':\n          return;\n\n        case 'datum,object,number':\n          {\n            this.inputLookup = _lookup2.default.addKeys(value.input, this.inputLookup);\n\n            if (this.inputLookup) {\n              this.inputLookupLength = Object.keys(this.inputLookup).length;\n            }\n\n            this.outputLookup = _lookup2.default.addKeys(value.output, this.outputLookup);\n\n            if (this.outputLookup) {\n              this.outputLookupLength = Object.keys(this.outputLookup).length;\n            }\n\n            break;\n          }\n\n        case 'object,number':\n          {\n            this.inputLookup = this.outputLookup = _lookup2.default.addKeys(value, this.inputLookup);\n\n            if (this.inputLookup) {\n              this.inputLookupLength = this.outputLookupLength = Object.keys(this.inputLookup).length;\n            }\n\n            break;\n          }\n\n        case 'array,object,number':\n          {\n            for (var i = 0; i < value.length; i++) {\n              this.inputLookup = this.outputLookup = _lookup2.default.addKeys(value[i], this.inputLookup);\n\n              if (this.inputLookup) {\n                this.inputLookupLength = this.outputLookupLength = Object.keys(this.inputLookup).length;\n              }\n            }\n\n            break;\n          }\n\n        case 'datum,array,object,number':\n          {\n            for (var _i19 = 0; _i19 < value.input.length; _i19++) {\n              this.inputLookup = _lookup2.default.addKeys(value.input[_i19], this.inputLookup);\n\n              if (this.inputLookup) {\n                this.inputLookupLength = Object.keys(this.inputLookup).length;\n              }\n            }\n\n            for (var _i20 = 0; _i20 < value.output.length; _i20++) {\n              this.outputLookup = _lookup2.default.addKeys(value.output[_i20], this.outputLookup);\n\n              if (this.outputLookup) {\n                this.outputLookupLength = Object.keys(this.outputLookup).length;\n              }\n            }\n\n            break;\n          }\n\n        default:\n          throw new Error('unknown data shape or configuration');\n      }\n    }\n    /**\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var defaults = this.constructor.defaults;\n\n      if (!this.model) {\n        this.initialize();\n      }\n\n      var model = this.model;\n      var options = {};\n\n      for (var p in defaults) {\n        if (defaults.hasOwnProperty(p)) {\n          options[p] = this[p];\n        }\n      }\n\n      return {\n        type: this.constructor.name,\n        options: options,\n        hiddenLayers: model.hiddenLayers.map(function (hiddenLayer) {\n          var layers = {};\n\n          for (var _p3 in hiddenLayer) {\n            layers[_p3] = hiddenLayer[_p3].toJSON();\n          }\n\n          return layers;\n        }),\n        outputConnector: this.model.outputConnector.toJSON(),\n        output: this.model.output.toJSON()\n      };\n    }\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(json) {\n      var defaults = this.constructor.defaults;\n      var options = json.options;\n      this.model = null;\n      this.hiddenLayers = null;\n      var allMatrices = [];\n      var hiddenLayers = []; // backward compatibility for hiddenSizes\n\n      (json.hiddenLayers || json.hiddenSizes).forEach(function (hiddenLayer) {\n        var layers = {};\n\n        for (var p in hiddenLayer) {\n          layers[p] = _matrix2.default.fromJSON(hiddenLayer[p]);\n          allMatrices.push(layers[p]);\n        }\n\n        hiddenLayers.push(layers);\n      });\n\n      var outputConnector = _matrix2.default.fromJSON(json.outputConnector);\n\n      allMatrices.push(outputConnector);\n\n      var output = _matrix2.default.fromJSON(json.output);\n\n      allMatrices.push(output);\n      Object.assign(this, defaults, options); // backward compatibility\n\n      if (options.hiddenSizes) {\n        this.hiddenLayers = options.hiddenSizes;\n      }\n\n      this.model = {\n        hiddenLayers: hiddenLayers,\n        output: output,\n        allMatrices: allMatrices,\n        outputConnector: outputConnector,\n        equations: [],\n        equationConnections: []\n      };\n      this.initialLayerInputs = this.hiddenLayers.map(function (size) {\n        return new _matrix2.default(size, 1);\n      });\n      this.bindEquation();\n    }\n    /**\n     *\n     * @returns {Function}\n     */\n\n  }, {\n    key: 'toFunction',\n    value: function toFunction() {\n      var model = this.model;\n      var equations = this.model.equations;\n      var inputSize = this.inputSize;\n      var inputLookup = this.inputLookup;\n      var inputLookupLength = this.inputLookupLength;\n      var outputLookup = this.outputLookup;\n      var outputLookupLength = this.outputLookupLength;\n      var equation = equations[1];\n      var states = equation.states;\n      var jsonString = JSON.stringify(this.toJSON());\n\n      function matrixOrigin(m, stateIndex) {\n        for (var i = 0, max = states.length; i < max; i++) {\n          var state = states[i];\n\n          if (i === stateIndex) {\n            var j = previousConnectionIndex(m);\n\n            switch (m) {\n              case state.left:\n                if (j > -1) {\n                  return 'typeof prevStates[' + j + '] === \\'object\\' ? prevStates[' + j + '].product : new Matrix(' + m.rows + ', ' + m.columns + ')';\n                }\n\n              case state.right:\n                if (j > -1) {\n                  return 'typeof prevStates[' + j + '] === \\'object\\' ? prevStates[' + j + '].product : new Matrix(' + m.rows + ', ' + m.columns + ')';\n                }\n\n              case state.product:\n                return 'new Matrix(' + m.rows + ', ' + m.columns + ')';\n\n              default:\n                throw Error('unknown state');\n            }\n          }\n\n          if (m === state.product) return 'states[' + i + '].product';\n          if (m === state.right) return 'states[' + i + '].right';\n          if (m === state.left) return 'states[' + i + '].left';\n        }\n      }\n\n      function previousConnectionIndex(m) {\n        var connection = model.equationConnections[0];\n        var states = equations[0].states;\n\n        for (var i = 0, max = states.length; i < max; i++) {\n          if (states[i].product === m) {\n            return i;\n          }\n        }\n\n        return connection.indexOf(m);\n      }\n\n      function matrixToString(m, stateIndex) {\n        if (!m || !m.rows || !m.columns) return 'null';\n        if (m === model.outputConnector) return 'json.outputConnector';\n        if (m === model.output) return 'json.output';\n\n        for (var i = 0, max = model.hiddenLayers.length; i < max; i++) {\n          var hiddenLayer = model.hiddenLayers[i];\n\n          for (var p in hiddenLayer) {\n            if (!hiddenLayer.hasOwnProperty(p)) continue;\n            if (hiddenLayer[p] !== m) continue;\n            return 'json.hiddenLayers[' + i + '].' + p;\n          }\n        }\n\n        return matrixOrigin(m, stateIndex);\n      }\n\n      function formatInputData() {\n        if (!inputLookup) return '';\n\n        if (inputSize === 1) {\n          if (inputLookup === outputLookup) {\n            return 'function lookupInput(input) {\\n            var table = ' + JSON.stringify(inputLookup) + ';\\n            var result = [];\\n            for (var p in table) {\\n              if (!input.hasOwnProperty(p)) break;\\n              result.push(Float32Array.from([input[p]]));\\n            }\\n            return result;\\n          }';\n          }\n\n          return 'function lookupInput(input) {\\n          var table = ' + JSON.stringify(inputLookup) + ';\\n          var result = [];\\n          for (var p in table) {\\n            result.push(Float32Array.from([input[p]]));\\n          }\\n          return result;\\n        }';\n        }\n\n        return 'function lookupInput(rawInputs) {\\n        var table = ' + JSON.stringify(inputLookup) + ';\\n        var result = [];\\n        for (var i = 0; i < rawInputs.length; i++) {\\n          var rawInput = rawInputs[i];\\n          var input = new Float32Array(' + inputLookupLength + ');\\n          for (var p in table) {\\n            input[table[p]] = rawInput.hasOwnProperty(p) ? rawInput[p] : 0;\\n          }\\n          result.push(input);\\n        }\\n        return result;\\n      }';\n      }\n\n      function formatOutputData() {\n        if (!outputLookup) return '';\n\n        if (inputSize === 1) {\n          if (inputLookup === outputLookup) {\n            return 'function lookupOutputPartial(output, input) {\\n            var table = ' + JSON.stringify(outputLookup) + ';\\n            var offset = input.length;\\n            var result = {};\\n            var i = 0;\\n            for (var p in table) {\\n              if (i++ < offset) continue;\\n              result[p] = output[table[p] - offset][0];\\n            }\\n            return result;\\n          }';\n          }\n\n          return 'function lookupOutput(output) {\\n          var table = ' + JSON.stringify(outputLookup) + ';\\n          var result = {};\\n          for (var p in table) {\\n            result[p] = output[table[p]][0];\\n          }\\n          return result;\\n        }';\n        }\n\n        return 'function lookupOutput(output) {\\n        var table = ' + JSON.stringify(outputLookup) + ';\\n        var result = {};\\n        for (var p in table) {\\n          result[p] = output[table[p]];\\n        }\\n        return result;\\n      }';\n      }\n\n      function toInner(fnString) {\n        // crude, but should be sufficient for now\n        // function() { body }\n        fnString = fnString.toString().split('{');\n        fnString.shift(); // body }\n\n        fnString = fnString.join('{');\n        fnString = fnString.split('}');\n        fnString.pop(); // body\n\n        return fnString.join('}').split('\\n').join('\\n        ').replace('product.weights = _input.weights = _this.inputValue;', inputLookup && inputSize === 1 ? 'product.weights = _i < input.length ? input[_i]: prevStates[prevStates.length - 1].product.weights;' : inputSize === 1 ? 'product.weights = [input[_i]];' : 'product.weights = input[_i];').replace('product.deltas[i] = 0;', '').replace('product.deltas[column] = 0;', '').replace('left.deltas[leftIndex] = 0;', '').replace('right.deltas[rightIndex] = 0;', '').replace('product.deltas = left.deltas.slice(0);', '');\n      }\n\n      function fileName(fnName) {\n        return 'src/recurrent/matrix/' + fnName.replace(/[A-Z]/g, function (value) {\n          return '-' + value.toLowerCase();\n        }) + '.js';\n      }\n\n      var statesRaw = [];\n      var usedFunctionNames = {};\n      var innerFunctionsSwitch = [];\n\n      for (var i = 0, max = states.length; i < max; i++) {\n        var state = states[i];\n        statesRaw.push('states[' + i + '] = {\\n      name: \\'' + state.forwardFn.name + '\\',\\n      left: ' + matrixToString(state.left, i) + ',\\n      right: ' + matrixToString(state.right, i) + ',\\n      product: ' + matrixToString(state.product, i) + '\\n    }');\n        var fnName = state.forwardFn.name;\n\n        if (!usedFunctionNames[fnName]) {\n          usedFunctionNames[fnName] = true;\n          innerFunctionsSwitch.push('        case \\'' + fnName + '\\':' + (fnName !== 'forwardFn' ? ' //compiled from ' + fileName(fnName) : '') + '\\n          ' + toInner(state.forwardFn.toString()) + '\\n          break;');\n        }\n      }\n\n      var forceForecast = this.inputSize === 1 && this.outputLookup;\n\n      var src = '\\n  var input = ' + (this.inputLookup ? 'lookupInput(rawInput)' : 'rawInput') + ';\\n  var json = ' + jsonString + ';\\n  var output = [];\\n  var states = [];\\n  var prevStates;\\n  var state;\\n  var max = ' + (forceForecast ? inputLookup === outputLookup ? inputLookupLength : 'input.length + ' + (outputLookupLength - 1) : 'input.length') + ';\\n  for (var _i = 0; _i < max; _i++) {\\n    prevStates = states;\\n    states = [];\\n    ' + statesRaw.join(';\\n    ') + ';\\n    for (var stateIndex = 0, stateMax = ' + statesRaw.length + '; stateIndex < stateMax; stateIndex++) {\\n      state = states[stateIndex];\\n      var product = state.product;\\n      var left = state.left;\\n      var right = state.right;\\n      \\n      switch (state.name) {\\n' + innerFunctionsSwitch.join('\\n') + '\\n      }\\n    }\\n    ' + (inputSize === 1 && inputLookup ? 'if (_i >= input.length - 1) { output.push(state.product.weights); }' : 'output = state.product.weights;') + '\\n  }\\n  ' + (outputLookup ? outputLookup === inputLookup ? 'return lookupOutputPartial(output, input)' : 'return lookupOutput(output)' : inputSize === 1 ? 'return output[0]' : 'return output') + ';\\n  ' + formatInputData() + '\\n  ' + formatOutputData() + '\\n  \\n  function Matrix(rows, columns) {\\n    this.rows = rows;\\n    this.columns = columns;\\n    this.weights = zeros(rows * columns);\\n  }\\n  ' + _zeros2.default.toString() + '\\n  ' + _softmax2.default.toString().replace('_2.default', 'Matrix') + '\\n  ' + _random.randomF.toString() + '\\n  ' + _sampleI2.default.toString() + '\\n  ' + _maxI2.default.toString();\n\n      return new Function('rawInput', src);\n    }\n  }]);\n\n  return RNNTimeStep;\n}(_rnn2.default);\n\nexports.default = RNNTimeStep;\nRNNTimeStep.defaults = {\n  inputSize: 1,\n  hiddenLayers: [20],\n  outputSize: 1,\n  learningRate: _rnn2.default.defaults.learningRate,\n  decayRate: _rnn2.default.defaults.decayRate,\n  smoothEps: _rnn2.default.defaults.smoothEps,\n  regc: _rnn2.default.defaults.regc,\n  clipval: _rnn2.default.defaults.clipval\n};\nRNNTimeStep.trainDefaults = _rnn2.default.trainDefaults;","map":null,"metadata":{},"sourceType":"script"}