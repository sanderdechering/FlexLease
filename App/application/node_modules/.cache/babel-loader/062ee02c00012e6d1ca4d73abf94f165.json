{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _stream = require('stream');\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n *\n * @param opts\n * @returns {TrainStream}\n * @constructor\n */\n\n\nvar TrainStream = function (_Writable) {\n  _inherits(TrainStream, _Writable);\n\n  function TrainStream(options) {\n    _classCallCheck(this, TrainStream);\n\n    var _this = _possibleConstructorReturn(this, (TrainStream.__proto__ || Object.getPrototypeOf(TrainStream)).call(this, {\n      objectMode: true\n    }));\n\n    options = options || {}; // require the neuralNetwork\n\n    if (!options.neuralNetwork) {\n      throw new Error('no neural network specified');\n    }\n\n    var _options = options,\n        neuralNetwork = _options.neuralNetwork;\n    _this.neuralNetwork = neuralNetwork;\n    _this.dataFormatDetermined = false;\n    _this.i = 0; // keep track of internal iterations\n\n    _this.size = 0;\n    _this.count = 0;\n    _this.sum = 0;\n    _this.floodCallback = options.floodCallback;\n    _this.doneTrainingCallback = options.doneTrainingCallback; // inherit trainOpts settings from neuralNetwork\n\n    neuralNetwork.updateTrainingOptions(options);\n    var trainOpts = neuralNetwork.trainOpts;\n    _this.iterations = trainOpts.iterations;\n    _this.errorThresh = trainOpts.errorThresh;\n    _this.log = trainOpts.log;\n    _this.logPeriod = trainOpts.logPeriod;\n    _this.callbackPeriod = trainOpts.callbackPeriod;\n    _this.callback = trainOpts.callback;\n\n    _this.on('finish', _this.finishStreamIteration.bind(_this));\n\n    return _this;\n  }\n\n  _createClass(TrainStream, [{\n    key: 'endInputs',\n    value: function endInputs() {\n      this.write(false);\n    }\n    /**\n     * _write expects data to be in the form of a datum. ie. {input: {a: 1 b: 0}, output: {z: 0}}\n     * @param chunk\n     * @param enc\n     * @param next\n     * @returns {*}\n     * @private\n     */\n\n  }, {\n    key: '_write',\n    value: function _write(chunk, enc, next) {\n      if (!chunk) {\n        // check for the end of one iteration of the stream\n        this.emit('finish');\n        return next();\n      }\n\n      if (!this.dataFormatDetermined) {\n        this.size++;\n        this.neuralNetwork.addFormat(chunk);\n        this.firstDatum = this.firstDatum || chunk;\n        return next();\n      }\n\n      this.count++;\n      var data = this.neuralNetwork.formatData(chunk);\n      this.sum += this.neuralNetwork.trainPattern(data[0], true); // tell the Readable Stream that we are ready for more data\n\n      next();\n    }\n    /**\n     *\n     * @returns {*}\n     */\n\n  }, {\n    key: 'finishStreamIteration',\n    value: function finishStreamIteration() {\n      if (this.dataFormatDetermined && this.size !== this.count) {\n        this.log('This iteration\\'s data length was different from the first.');\n      }\n\n      if (!this.dataFormatDetermined) {\n        var data = this.neuralNetwork.formatData(this.firstDatum);\n        this.neuralNetwork.verifyIsInitialized(data);\n        this.dataFormatDetermined = true;\n\n        if (typeof this.floodCallback === 'function') {\n          this.floodCallback();\n        }\n\n        return;\n      }\n\n      var error = this.sum / this.size;\n\n      if (this.log && this.i % this.logPeriod === 0) {\n        this.log('iterations: ' + this.i + ', training error: ' + error);\n      }\n\n      if (this.callback && this.i % this.callbackPeriod === 0) {\n        this.callback({\n          error: error,\n          iterations: this.i\n        });\n      }\n\n      this.sum = 0;\n      this.count = 0; // update the iterations\n\n      this.i++; // do a check here to see if we need the stream again\n\n      if (this.i < this.iterations && error > this.errorThresh) {\n        if (typeof this.floodCallback === 'function') {\n          return this.floodCallback();\n        }\n      } else {\n        // done training\n        if (typeof this.doneTrainingCallback === 'function') {\n          return this.doneTrainingCallback({\n            error: error,\n            iterations: this.i\n          });\n        }\n      }\n    }\n  }]);\n\n  return TrainStream;\n}(_stream.Writable);\n\nexports.default = TrainStream;","map":null,"metadata":{},"sourceType":"script"}