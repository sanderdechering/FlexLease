{"ast":null,"code":"'use strict';\n\nvar _get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar KernelBase = require('../kernel-base');\n\nvar utils = require('../../core/utils');\n\nvar Texture = require('../../core/texture');\n\nvar fragShaderString = require('./shader-frag');\n\nvar vertShaderString = require('./shader-vert');\n\nvar kernelString = require('./kernel-string');\n\nvar canvases = [];\nvar maxTexSizes = {};\n\nmodule.exports = function (_KernelBase) {\n  _inherits(WebGLKernel, _KernelBase);\n\n  _createClass(WebGLKernel, null, [{\n    key: 'fragShaderString',\n    get: function get() {\n      return fragShaderString;\n    }\n  }, {\n    key: 'vertShaderString',\n    get: function get() {\n      return vertShaderString;\n    }\n    /**\n     * @constructor WebGLKernel\n     *\n     * @desc Kernel Implementation for WebGL.\n     * <p>This builds the shaders and runs them on the GPU,\n     * the outputs the result back as float(enabled by default) and Texture.</p>\n     *\n     * @extends KernelBase\n     *\n     * @prop {Object} textureCache - webGl Texture cache\n     * @prop {Object} threadDim - The thread dimensions, x, y and z\n     * @prop {Object} programUniformLocationCache - Location of program variables in memory\n     * @prop {Object} framebuffer - Webgl frameBuffer\n     * @prop {Object} buffer - WebGL buffer\n     * @prop {Object} program - The webGl Program\n     * @prop {Object} functionBuilder - Function Builder instance bound to this Kernel\n     * @prop {Boolean} outputToTexture - Set output type to Texture, instead of float\n     * @prop {String} endianness - Endian information like Little-endian, Big-endian.\n     * @prop {Array} paramTypes - Types of parameters sent to the Kernel\n     * @prop {number} argumentsLength - Number of parameters sent to the Kernel\n     * @prop {String} compiledFragShaderString - Compiled fragment shader string\n     * @prop {String} compiledVertShaderString - Compiled Vertical shader string\n     */\n\n  }]);\n\n  function WebGLKernel(fnString, settings) {\n    _classCallCheck(this, WebGLKernel);\n\n    var _this = _possibleConstructorReturn(this, (WebGLKernel.__proto__ || Object.getPrototypeOf(WebGLKernel)).call(this, fnString, settings));\n\n    _this.textureCache = {};\n    _this.threadDim = {};\n    _this.programUniformLocationCache = {};\n    _this.framebuffer = null;\n    _this.buffer = null;\n    _this.program = null;\n    _this.outputToTexture = settings.outputToTexture;\n    _this.endianness = utils.systemEndianness();\n    _this.subKernelOutputTextures = null;\n    _this.subKernelOutputVariableNames = null;\n    _this.argumentsLength = 0;\n    _this.constantsLength = 0;\n    _this.compiledFragShaderString = null;\n    _this.compiledVertShaderString = null;\n    _this.fragShader = null;\n    _this.vertShader = null;\n    _this.drawBuffersMap = null;\n    _this.outputTexture = null;\n    _this.maxTexSize = null;\n    _this.uniform1fCache = {};\n    _this.uniform1iCache = {};\n    _this.uniform2fCache = {};\n    _this.uniform2fvCache = {};\n    _this.uniform2ivCache = {};\n    _this.uniform3fvCache = {};\n    _this.uniform3ivCache = {};\n    if (!_this._webGl) _this._webGl = _this.initWebGl();\n    return _this;\n  }\n\n  _createClass(WebGLKernel, [{\n    key: 'initWebGl',\n    value: function initWebGl() {\n      return utils.initWebGl(this.getCanvas());\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name validateOptions\n     *\n     * @desc Validate options related to Kernel, such as\n     * floatOutputs and Textures, texSize, output,\n     * graphical output.\n     *\n     */\n\n  }, {\n    key: 'validateOptions',\n    value: function validateOptions() {\n      var isFloatReadPixel = utils.isFloatReadPixelsSupported();\n\n      if (this.floatTextures === true && !utils.OES_texture_float) {\n        throw new Error('Float textures are not supported on this browser');\n      } else if (this.floatOutput === true && this.floatOutputForce !== true && !isFloatReadPixel) {\n        throw new Error('Float texture outputs are not supported on this browser');\n      } else if (this.floatTextures === undefined && utils.OES_texture_float) {\n        this.floatTextures = true;\n        this.floatOutput = isFloatReadPixel;\n      }\n\n      var hasIntegerDivisionBug = utils.hasIntegerDivisionAccuracyBug();\n\n      if (this.fixIntegerDivisionAccuracy === null) {\n        this.fixIntegerDivisionAccuracy = hasIntegerDivisionBug;\n      } else if (this.fixIntegerDivisionAccuracy && !hasIntegerDivisionBug) {\n        this.fixIntegerDivisionAccuracy = false;\n      }\n\n      utils.checkOutput(this.output);\n\n      if (!this.output || this.output.length === 0) {\n        if (arguments.length !== 1) {\n          throw new Error('Auto output only supported for kernels with only one input');\n        }\n\n        var argType = utils.getArgumentType(arguments[0]);\n\n        if (argType === 'Array') {\n          this.output = utils.getDimensions(argType);\n        } else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {\n          this.output = arguments[0].output;\n        } else {\n          throw new Error('Auto output not supported for input type: ' + argType);\n        }\n      }\n\n      this.texSize = utils.dimToTexSize({\n        floatTextures: this.floatTextures,\n        floatOutput: this.floatOutput\n      }, this.output, true);\n\n      if (this.graphical) {\n        if (this.output.length !== 2) {\n          throw new Error('Output must have 2 dimensions on graphical mode');\n        }\n\n        if (this.floatOutput) {\n          this.floatOutput = false;\n          console.warn('Cannot use graphical mode and float output at the same time');\n        }\n\n        this.texSize = utils.clone(this.output);\n      } else if (this.floatOutput === undefined && utils.OES_texture_float) {\n        this.floatOutput = true;\n      }\n    }\n  }, {\n    key: 'updateMaxTexSize',\n    value: function updateMaxTexSize() {\n      var texSize = this.texSize;\n      var canvas = this._canvas;\n\n      if (this.maxTexSize === null) {\n        var canvasIndex = canvases.indexOf(canvas);\n\n        if (canvasIndex === -1) {\n          canvasIndex = canvases.length;\n          canvases.push(canvas);\n          maxTexSizes[canvasIndex] = [texSize[0], texSize[1]];\n        }\n\n        this.maxTexSize = maxTexSizes[canvasIndex];\n      }\n\n      if (this.maxTexSize[0] < texSize[0]) {\n        this.maxTexSize[0] = texSize[0];\n      }\n\n      if (this.maxTexSize[1] < texSize[1]) {\n        this.maxTexSize[1] = texSize[1];\n      }\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name build\n     *\n     * @desc Builds the Kernel, by compiling Fragment and Vertical Shaders,\n     * and instantiates the program.\n     *\n     */\n\n  }, {\n    key: 'build',\n    value: function build() {\n      this.validateOptions();\n      this.setupConstants();\n      this.setupParams(arguments);\n      this.updateMaxTexSize();\n      var texSize = this.texSize;\n      var gl = this._webGl;\n      var canvas = this._canvas;\n      gl.enable(gl.SCISSOR_TEST);\n      gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);\n      canvas.width = this.maxTexSize[0];\n      canvas.height = this.maxTexSize[1];\n      var threadDim = this.threadDim = utils.clone(this.output);\n\n      while (threadDim.length < 3) {\n        threadDim.push(1);\n      }\n\n      if (this.functionBuilder) this._addKernels();\n\n      var compiledVertShaderString = this._getVertShaderString(arguments);\n\n      var vertShader = gl.createShader(gl.VERTEX_SHADER);\n      gl.shaderSource(vertShader, compiledVertShaderString);\n      gl.compileShader(vertShader);\n      this.vertShader = vertShader;\n\n      var compiledFragShaderString = this._getFragShaderString(arguments);\n\n      var fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n      gl.shaderSource(fragShader, compiledFragShaderString);\n      gl.compileShader(fragShader);\n      this.fragShader = fragShader;\n\n      if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {\n        console.log(compiledVertShaderString);\n        console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(vertShader));\n        throw new Error('Error compiling vertex shader');\n      }\n\n      if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {\n        console.log(compiledFragShaderString);\n        console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(fragShader));\n        throw new Error('Error compiling fragment shader');\n      }\n\n      if (this.debug) {\n        console.log('Options:');\n        console.dir(this);\n        console.log('GLSL Shader Output:');\n        console.log(compiledFragShaderString);\n      }\n\n      var program = this.program = gl.createProgram();\n      gl.attachShader(program, vertShader);\n      gl.attachShader(program, fragShader);\n      gl.linkProgram(program);\n      this.framebuffer = gl.createFramebuffer();\n      this.framebuffer.width = texSize[0];\n      this.framebuffer.height = texSize[1];\n      var vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);\n      var texCoords = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n      var texCoordOffset = vertices.byteLength;\n      var buffer = this.buffer;\n\n      if (!buffer) {\n        buffer = this.buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ARRAY_BUFFER, vertices.byteLength + texCoords.byteLength, gl.STATIC_DRAW);\n      } else {\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      }\n\n      gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);\n      gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);\n      var aPosLoc = gl.getAttribLocation(this.program, 'aPos');\n      gl.enableVertexAttribArray(aPosLoc);\n      gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, gl.FALSE, 0, 0);\n      var aTexCoordLoc = gl.getAttribLocation(this.program, 'aTexCoord');\n      gl.enableVertexAttribArray(aTexCoordLoc);\n      gl.vertexAttribPointer(aTexCoordLoc, 2, gl.FLOAT, gl.FALSE, 0, texCoordOffset);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n\n      for (var p in this.constants) {\n        var value = this.constants[p];\n        var type = utils.getArgumentType(value);\n\n        if (type === 'Float' || type === 'Integer') {\n          continue;\n        }\n\n        gl.useProgram(this.program);\n\n        this._addConstant(this.constants[p], type, p);\n\n        this.constantsLength++;\n      }\n\n      if (!this.outputImmutable) {\n        this._setupOutputTexture();\n\n        if (this.subKernelOutputVariableNames !== null && this.subKernelOutputVariableNames.length > 0) {\n          this._setupSubOutputTextures(this.subKernelOutputVariableNames.length);\n        }\n      }\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name run\n     *\n     * @desc Run the kernel program, and send the output to renderOutput\n     *\n     * <p> This method calls a helper method *renderOutput* to return the result. </p>\n     *\n     * @returns {Object|Undefined} Result The final output of the program, as float, and as Textures for reuse.\n     *\n     *\n     */\n\n  }, {\n    key: 'run',\n    value: function run() {\n      if (this.program === null) {\n        this.build.apply(this, arguments);\n      }\n\n      var paramNames = this.paramNames;\n      var paramTypes = this.paramTypes;\n      var texSize = this.texSize;\n      var gl = this._webGl;\n      gl.useProgram(this.program);\n      gl.scissor(0, 0, texSize[0], texSize[1]);\n\n      if (!this.hardcodeConstants) {\n        this.setUniform3iv('uOutputDim', this.threadDim);\n        this.setUniform2iv('uTexSize', texSize);\n      }\n\n      this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);\n      this.argumentsLength = 0;\n\n      for (var texIndex = 0; texIndex < paramNames.length; texIndex++) {\n        this._addArgument(arguments[texIndex], paramTypes[texIndex], paramNames[texIndex]);\n      }\n\n      if (this.graphical) {\n        if (this.outputToTexture) {\n          gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n\n          if (!this.outputTexture || this.outputImmutable) {\n            this._setupOutputTexture();\n          }\n\n          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n          return new Texture(this.outputTexture, texSize, this.threadDim, this.output, this._webGl, 'ArrayTexture(4)');\n        }\n\n        gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n        return;\n      }\n\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n\n      if (this.outputImmutable) {\n        this._setupOutputTexture();\n      }\n\n      var outputTexture = this.outputTexture;\n\n      if (this.subKernelOutputVariableNames !== null) {\n        if (this.outputImmutable) {\n          this.subKernelOutputTextures = [];\n\n          this._setupSubOutputTextures(this.subKernelOutputVariableNames.length);\n        }\n\n        this.drawBuffers.drawBuffersWEBGL(this.drawBuffersMap);\n      }\n\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\n      if (this.subKernelOutputTextures !== null) {\n        if (this.subKernels !== null) {\n          var output = [];\n          output.result = this.renderOutput(outputTexture);\n\n          for (var i = 0; i < this.subKernels.length; i++) {\n            output.push(new Texture(this.subKernelOutputTextures[i], texSize, this.threadDim, this.output, this._webGl));\n          }\n\n          return output;\n        } else if (this.subKernelProperties !== null) {\n          var _output = {\n            result: this.renderOutput(outputTexture)\n          };\n          var _i = 0;\n\n          for (var p in this.subKernelProperties) {\n            if (!this.subKernelProperties.hasOwnProperty(p)) continue;\n            _output[p] = new Texture(this.subKernelOutputTextures[_i], texSize, this.threadDim, this.output, this._webGl);\n            _i++;\n          }\n\n          return _output;\n        }\n      }\n\n      return this.renderOutput(outputTexture);\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name renderOutput\n     *\n     *\n     * @desc Helper function to return webGl function's output.\n     * Since the program runs on GPU, we need to get the\n     * output of the program back to CPU and then return them.\n     *\n     * *Note*: This should not be called directly.\n     *\n     * @param {Object} outputTexture - Output Texture returned by webGl program\n     *\n     * @returns {Object|Array} result\n     *\n     *\n     */\n\n  }, {\n    key: 'renderOutput',\n    value: function renderOutput(outputTexture) {\n      var texSize = this.texSize;\n      var gl = this._webGl;\n      var threadDim = this.threadDim;\n      var output = this.output;\n\n      if (this.outputToTexture) {\n        return new Texture(outputTexture, texSize, this.threadDim, output, this._webGl);\n      } else {\n        var result = void 0;\n\n        if (this.floatOutput) {\n          var w = texSize[0];\n          var h = Math.ceil(texSize[1] / 4);\n          result = new Float32Array(w * h * 4);\n          gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);\n        } else {\n          var bytes = new Uint8Array(texSize[0] * texSize[1] * 4);\n          gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, bytes);\n          result = new Float32Array(bytes.buffer);\n        }\n\n        result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);\n\n        if (output.length === 1) {\n          return result;\n        } else if (output.length === 2) {\n          return utils.splitArray(result, output[0]);\n        } else if (output.length === 3) {\n          var cube = utils.splitArray(result, output[0] * output[1]);\n          return cube.map(function (x) {\n            return utils.splitArray(x, output[0]);\n          });\n        }\n      }\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name getOutputTexture\n     *\n     * @desc This return defined outputTexture, which is setup in .build(), or if immutable, is defined in .run()\n     *\n     * @returns {Object} Output Texture Cache\n     *\n     */\n\n  }, {\n    key: 'getOutputTexture',\n    value: function getOutputTexture() {\n      return this.outputTexture;\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _setupOutputTexture\n     * @private\n     *\n     * @desc Setup and replace output texture\n     */\n\n  }, {\n    key: '_setupOutputTexture',\n    value: function _setupOutputTexture() {\n      var gl = this._webGl;\n      var texSize = this.texSize;\n\n      var texture = this.outputTexture = this._webGl.createTexture();\n\n      gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.paramNames.length);\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n      if (this.floatOutput) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);\n      } else {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      }\n\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @param length\n     * @private\n     *\n     * @desc Setup and replace sub-output textures\n     */\n\n  }, {\n    key: '_setupSubOutputTextures',\n    value: function _setupSubOutputTextures(length) {\n      var gl = this._webGl;\n      var texSize = this.texSize;\n      var drawBuffersMap = this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];\n      var textures = this.subKernelOutputTextures = [];\n\n      for (var i = 0; i < length; i++) {\n        var texture = this._webGl.createTexture();\n\n        textures.push(texture);\n        drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);\n        gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.paramNames.length + i);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n        if (this.floatOutput) {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);\n        } else {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);\n      }\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name getArgumentTexture\n     *\n     * @desc This uses *getTextureCache** to get the Texture Cache of the argument supplied\n     *\n     * @param {String} name - Name of the argument\n     *\n     * \tTexture cache for the supplied argument\n     *\n     */\n\n  }, {\n    key: 'getArgumentTexture',\n    value: function getArgumentTexture(name) {\n      return this.getTextureCache('ARGUMENT_' + name);\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @name getTextureCache\n     * @function\n     *\n     * @desc Returns the Texture Cache of the supplied parameter (can be kernel, sub-kernel or argument)\n     *\n     * @param {String} name - Name of the subkernel, argument, or kernel.\n     *\n     * @returns {Object} Texture cache\n     *\n     */\n\n  }, {\n    key: 'getTextureCache',\n    value: function getTextureCache(name) {\n      if (this.textureCache.hasOwnProperty(name)) {\n        return this.textureCache[name];\n      }\n\n      return this.textureCache[name] = this._webGl.createTexture();\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @name detachTextureCache\n     * @function\n     * @desc removes a texture from the kernel's cache\n     * @param {String} name - Name of texture\n     */\n\n  }, {\n    key: 'detachTextureCache',\n    value: function detachTextureCache(name) {\n      delete this.textureCache[name];\n    }\n  }, {\n    key: 'setUniform1f',\n    value: function setUniform1f(name, value) {\n      if (this.uniform1fCache.hasOwnProperty(name)) {\n        var cache = this.uniform1fCache[name];\n\n        if (value === cache) {\n          return;\n        }\n      }\n\n      this.uniform1fCache[name] = value;\n      var loc = this.getUniformLocation(name);\n\n      this._webGl.uniform1f(loc, value);\n    }\n  }, {\n    key: 'setUniform1i',\n    value: function setUniform1i(name, value) {\n      if (this.uniform1iCache.hasOwnProperty(name)) {\n        var cache = this.uniform1iCache[name];\n\n        if (value === cache) {\n          return;\n        }\n      }\n\n      this.uniform1iCache[name] = value;\n      var loc = this.getUniformLocation(name);\n\n      this._webGl.uniform1i(loc, value);\n    }\n  }, {\n    key: 'setUniform2f',\n    value: function setUniform2f(name, value1, value2) {\n      if (this.uniform2fCache.hasOwnProperty(name)) {\n        var cache = this.uniform2fCache[name];\n\n        if (value1 === cache[0] && value2 === cache[1]) {\n          return;\n        }\n      }\n\n      this.uniform2fCache[name] = [value1, value2];\n      var loc = this.getUniformLocation(name);\n\n      this._webGl.uniform2f(loc, value1, value2);\n    }\n  }, {\n    key: 'setUniform2fv',\n    value: function setUniform2fv(name, value) {\n      if (this.uniform2fvCache.hasOwnProperty(name)) {\n        var cache = this.uniform2fvCache[name];\n\n        if (value[0] === cache[0] && value[1] === cache[1]) {\n          return;\n        }\n      }\n\n      this.uniform2fvCache[name] = value;\n      var loc = this.getUniformLocation(name);\n\n      this._webGl.uniform2fv(loc, value);\n    }\n  }, {\n    key: 'setUniform2iv',\n    value: function setUniform2iv(name, value) {\n      if (this.uniform2ivCache.hasOwnProperty(name)) {\n        var cache = this.uniform2ivCache[name];\n\n        if (value[0] === cache[0] && value[1] === cache[1]) {\n          return;\n        }\n      }\n\n      this.uniform2ivCache[name] = value;\n      var loc = this.getUniformLocation(name);\n\n      this._webGl.uniform2iv(loc, value);\n    }\n  }, {\n    key: 'setUniform3fv',\n    value: function setUniform3fv(name, value) {\n      if (this.uniform3fvCache.hasOwnProperty(name)) {\n        var cache = this.uniform3fvCache[name];\n\n        if (value[0] === cache[0] && value[1] === cache[1] && value[2] === cache[2]) {\n          return;\n        }\n      }\n\n      this.uniform3fvCache[name] = value;\n      var loc = this.getUniformLocation(name);\n\n      this._webGl.uniform3fv(loc, value);\n    }\n  }, {\n    key: 'setUniform3iv',\n    value: function setUniform3iv(name, value) {\n      if (this.uniform3ivCache.hasOwnProperty(name)) {\n        var cache = this.uniform3ivCache[name];\n\n        if (value[0] === cache[0] && value[1] === cache[1] && value[2] === cache[2]) {\n          return;\n        }\n      }\n\n      this.uniform3ivCache[name] = value;\n      var loc = this.getUniformLocation(name);\n\n      this._webGl.uniform3iv(loc, value);\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name getUniformLocation\n     *\n     * @desc Return WebGlUniformLocation for various variables\n     * related to webGl program, such as user-defiend variables,\n     * as well as, dimension sizes, etc.\n     *\n     */\n\n  }, {\n    key: 'getUniformLocation',\n    value: function getUniformLocation(name) {\n      if (this.programUniformLocationCache.hasOwnProperty(name)) {\n        return this.programUniformLocationCache[name];\n      }\n\n      return this.programUniformLocationCache[name] = this._webGl.getUniformLocation(this.program, name);\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getFragShaderArtifactMap\n     *\n     * @desc Generate Shader artifacts for the kernel program.\n     * The final object contains HEADER, KERNEL, MAIN_RESULT, and others.\n     *\n     * @param {Array} args - The actual parameters sent to the Kernel\n     *\n     * @returns {Object} An object containing the Shader Artifacts(CONSTANTS, HEADER, KERNEL, etc.)\n     *\n     */\n\n  }, {\n    key: '_getFragShaderArtifactMap',\n    value: function _getFragShaderArtifactMap(args) {\n      return {\n        HEADER: this._getHeaderString(),\n        LOOP_MAX: this._getLoopMaxString(),\n        CONSTANTS: this._getConstantsString(),\n        DECODE32_ENDIANNESS: this._getDecode32EndiannessString(),\n        ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(),\n        DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(),\n        GET_WRAPAROUND: this._getGetWraparoundString(),\n        GET_TEXTURE_CHANNEL: this._getGetTextureChannelString(),\n        GET_TEXTURE_INDEX: this._getGetTextureIndexString(),\n        GET_RESULT: this._getGetResultString(),\n        MAIN_PARAMS: this._getMainParamsString(args),\n        MAIN_CONSTANTS: this._getMainConstantsString(),\n        KERNEL: this._getKernelString(),\n        MAIN_RESULT: this._getMainResultString()\n      };\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _addArgument\n     *\n     * @desc Adds kernel parameters to the Argument Texture,\n     * binding it to the webGl instance, etc.\n     *\n     * @param {Array|Texture|Number} value - The actual argument supplied to the kernel\n     * @param {String} type - Type of the argument\n     * @param {String} name - Name of the argument\n     *\n     */\n\n  }, {\n    key: '_addArgument',\n    value: function _addArgument(value, type, name) {\n      var gl = this._webGl;\n      var argumentTexture = this.getArgumentTexture(name);\n\n      if (value instanceof Texture) {\n        type = value.type;\n      }\n\n      switch (type) {\n        case 'Array':\n        case 'Array(2)':\n        case 'Array(3)':\n        case 'Array(4)':\n        case 'Array2D':\n        case 'Array3D':\n          {\n            var dim = utils.getDimensions(value, true);\n            var size = utils.dimToTexSize({\n              floatTextures: this.floatTextures,\n              floatOutput: this.floatOutput\n            }, dim);\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);\n            gl.bindTexture(gl.TEXTURE_2D, argumentTexture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            var length = size[0] * size[1];\n\n            var _formatArrayTransfer2 = this._formatArrayTransfer(value, length),\n                valuesFlat = _formatArrayTransfer2.valuesFlat,\n                bitRatio = _formatArrayTransfer2.bitRatio;\n\n            var buffer = void 0;\n\n            if (this.floatTextures) {\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size[0], size[1], 0, gl.RGBA, gl.FLOAT, valuesFlat);\n            } else {\n              buffer = new Uint8Array(valuesFlat.buffer);\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size[0] / bitRatio, size[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);\n            }\n\n            if (!this.hardcodeConstants) {\n              this.setUniform3iv('user_' + name + 'Dim', dim);\n              this.setUniform2iv('user_' + name + 'Size', size);\n            }\n\n            this.setUniform1i('user_' + name + 'BitRatio', bitRatio);\n            this.setUniform1i('user_' + name, this.argumentsLength);\n            break;\n          }\n\n        case 'Integer':\n        case 'Float':\n        case 'Number':\n          {\n            this.setUniform1f('user_' + name, value);\n            break;\n          }\n\n        case 'Input':\n          {\n            var input = value;\n            var _dim = input.size;\n\n            var _size = utils.dimToTexSize({\n              floatTextures: this.floatTextures,\n              floatOutput: this.floatOutput\n            }, _dim);\n\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);\n            gl.bindTexture(gl.TEXTURE_2D, argumentTexture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n            var _length = _size[0] * _size[1];\n\n            var _formatArrayTransfer3 = this._formatArrayTransfer(value.value, _length),\n                _valuesFlat = _formatArrayTransfer3.valuesFlat,\n                _bitRatio = _formatArrayTransfer3.bitRatio;\n\n            if (this.floatTextures) {\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _size[0], _size[1], 0, gl.RGBA, gl.FLOAT, inputArray);\n            } else {\n              var _buffer = new Uint8Array(_valuesFlat.buffer);\n\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _size[0] / _bitRatio, _size[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, _buffer);\n            }\n\n            if (!this.hardcodeConstants) {\n              this.setUniform3iv('user_' + name + 'Dim', _dim);\n              this.setUniform2iv('user_' + name + 'Size', _size);\n            }\n\n            this.setUniform1i('user_' + name + 'BitRatio', _bitRatio);\n            this.setUniform1i('user_' + name, this.argumentsLength);\n            break;\n          }\n\n        case 'HTMLImage':\n          {\n            var inputImage = value;\n            var _dim2 = [inputImage.width, inputImage.height, 1];\n            var _size2 = [inputImage.width, inputImage.height];\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);\n            gl.bindTexture(gl.TEXTURE_2D, argumentTexture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // Upload the image into the texture.\n\n            var mipLevel = 0; // the largest mip\n\n            var internalFormat = gl.RGBA; // format we want in the texture\n\n            var srcFormat = gl.RGBA; // format of data we are supplying\n\n            var srcType = gl.UNSIGNED_BYTE; // type of data we are supplying\n\n            gl.texImage2D(gl.TEXTURE_2D, mipLevel, internalFormat, srcFormat, srcType, inputImage);\n            this.setUniform3iv('user_' + name + 'Dim', _dim2);\n            this.setUniform2iv('user_' + name + 'Size', _size2);\n            this.setUniform1i('user_' + name, this.argumentsLength);\n            break;\n          }\n\n        case 'ArrayTexture(4)':\n        case 'NumberTexture':\n          {\n            var inputTexture = value;\n            var _dim3 = inputTexture.dimensions;\n            var _size3 = inputTexture.size;\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);\n            gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);\n            this.setUniform3iv('user_' + name + 'Dim', _dim3);\n            this.setUniform2iv('user_' + name + 'Size', _size3);\n            this.setUniform1i('user_' + name + 'BitRatio', 1); // aways float32\n\n            this.setUniform1i('user_' + name, this.argumentsLength);\n            break;\n          }\n\n        default:\n          throw new Error('Input type not supported (WebGL): ' + value);\n      }\n\n      this.argumentsLength++;\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _addConstant\n     *\n     * @desc Adds kernel parameters to the Argument Texture,\n     * binding it to the webGl instance, etc.\n     *\n     * @param {Array|Texture|Number} value - The actual argument supplied to the kernel\n     * @param {String} type - Type of the argument\n     * @param {String} name - Name of the argument\n     *\n     */\n\n  }, {\n    key: '_addConstant',\n    value: function _addConstant(value, type, name) {\n      var gl = this._webGl;\n      var argumentTexture = this.getArgumentTexture(name);\n\n      if (value instanceof Texture) {\n        type = value.type;\n      }\n\n      switch (type) {\n        case 'Array':\n          {\n            var dim = utils.getDimensions(value, true);\n            var size = utils.dimToTexSize({\n              floatTextures: this.floatTextures,\n              floatOutput: this.floatOutput\n            }, dim);\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength);\n            gl.bindTexture(gl.TEXTURE_2D, argumentTexture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            var length = size[0] * size[1];\n\n            var _formatArrayTransfer4 = this._formatArrayTransfer(value, length),\n                valuesFlat = _formatArrayTransfer4.valuesFlat,\n                bitRatio = _formatArrayTransfer4.bitRatio;\n\n            var buffer = void 0;\n\n            if (this.floatTextures) {\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size[0], size[1], 0, gl.RGBA, gl.FLOAT, valuesFlat);\n            } else {\n              buffer = new Uint8Array(valuesFlat.buffer);\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size[0] / bitRatio, size[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);\n            }\n\n            if (!this.hardcodeConstants) {\n              this.setUniform3iv('constants_' + name + 'Dim', dim);\n              this.setUniform2iv('constants_' + name + 'Size', size);\n            }\n\n            this.setUniform1i('constants_' + name + 'BitRatio', bitRatio);\n            this.setUniform1i('constants_' + name, this.constantsLength);\n            break;\n          }\n\n        case 'Input':\n          {\n            var input = value;\n            var _dim4 = input.size;\n\n            var _size4 = utils.dimToTexSize({\n              floatTextures: this.floatTextures,\n              floatOutput: this.floatOutput\n            }, _dim4);\n\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength);\n            gl.bindTexture(gl.TEXTURE_2D, argumentTexture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n            var _length2 = _size4[0] * _size4[1];\n\n            var _formatArrayTransfer5 = this._formatArrayTransfer(value.value, _length2),\n                _valuesFlat2 = _formatArrayTransfer5.valuesFlat,\n                _bitRatio2 = _formatArrayTransfer5.bitRatio;\n\n            if (this.floatTextures) {\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _size4[0], _size4[1], 0, gl.RGBA, gl.FLOAT, inputArray);\n            } else {\n              var _buffer2 = new Uint8Array(_valuesFlat2.buffer);\n\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _size4[0] / _bitRatio2, _size4[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, _buffer2);\n            }\n\n            if (!this.hardcodeConstants) {\n              this.setUniform3iv('constants_' + name + 'Dim', _dim4);\n              this.setUniform2iv('constants_' + name + 'Size', _size4);\n            }\n\n            this.setUniform1i('constants_' + name + 'BitRatio', _bitRatio2);\n            this.setUniform1i('constants_' + name, this.constantsLength);\n            break;\n          }\n\n        case 'HTMLImage':\n          {\n            var inputImage = value;\n            var _dim5 = [inputImage.width, inputImage.height, 1];\n            var _size5 = [inputImage.width, inputImage.height];\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength);\n            gl.bindTexture(gl.TEXTURE_2D, argumentTexture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // Upload the image into the texture.\n\n            var mipLevel = 0; // the largest mip\n\n            var internalFormat = gl.RGBA; // format we want in the texture\n\n            var srcFormat = gl.RGBA; // format of data we are supplying\n\n            var srcType = gl.UNSIGNED_BYTE; // type of data we are supplying\n\n            gl.texImage2D(gl.TEXTURE_2D, mipLevel, internalFormat, srcFormat, srcType, inputImage);\n            this.setUniform3iv('constants_' + name + 'Dim', _dim5);\n            this.setUniform2iv('constants_' + name + 'Size', _size5);\n            this.setUniform1i('constants_' + name, this.constantsLength);\n            break;\n          }\n\n        case 'ArrayTexture(4)':\n        case 'NumberTexture':\n          {\n            var inputTexture = value;\n            var _dim6 = inputTexture.dimensions;\n            var _size6 = inputTexture.size;\n            gl.activeTexture(gl.TEXTURE0 + this.constantsLength);\n            gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);\n            this.setUniform3iv('constants_' + name + 'Dim', _dim6);\n            this.setUniform2iv('constants_' + name + 'Size', _size6);\n            this.setUniform1i('constants_' + name + 'BitRatio', 1); // aways float32\n\n            this.setUniform1i('constants_' + name, this.constantsLength);\n            break;\n          }\n\n        case 'Integer':\n        case 'Float':\n        default:\n          throw new Error('Input type not supported (WebGL): ' + value);\n      }\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _formatArrayTransfer\n     *\n     * @desc Adds kernel parameters to the Argument Texture,\n     * binding it to the webGl instance, etc.\n     *\n     * @param {Array} value - The actual argument supplied to the kernel\n     * @param {String} length - the expected total length of the output array\n     *\n     * @returns {Object} bitRatio - bit storage ratio of source to target 'buffer', i.e. if 8bit array -> 32bit tex = 4\n     * \t\t\t\t     valuesFlat - flattened array to transfer\n     */\n\n  }, {\n    key: '_formatArrayTransfer',\n    value: function _formatArrayTransfer(value, length) {\n      var bitRatio = 1; // bit storage ratio of source to target 'buffer', i.e. if 8bit array -> 32bit tex = 4\n\n      var valuesFlat = value;\n\n      if (utils.isArray(value[0]) || this.floatTextures) {\n        // not already flat\n        valuesFlat = new Float32Array(length);\n        utils.flattenTo(value, valuesFlat);\n      } else {\n        switch (value.constructor) {\n          case Uint8Array:\n          case Int8Array:\n            bitRatio = 4;\n            break;\n\n          case Uint16Array:\n          case Int16Array:\n            bitRatio = 2;\n\n          case Float32Array:\n          case Int32Array:\n            break;\n\n          default:\n            valuesFlat = new Float32Array(length);\n            utils.flattenTo(value, valuesFlat);\n        }\n      }\n\n      return {\n        bitRatio: bitRatio,\n        valuesFlat: valuesFlat\n      };\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getHeaderString\n     *\n     * @desc Get the header string for the program.\n     * This returns an empty string if no sub-kernels are defined.\n     *\n     * @returns {String} result\n     *\n     */\n\n  }, {\n    key: '_getHeaderString',\n    value: function _getHeaderString() {\n      return this.subKernels !== null || this.subKernelProperties !== null ? //webgl2 '#version 300 es\\n' :\n      '#extension GL_EXT_draw_buffers : require\\n' : '';\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getLoopMaxString\n     *\n     * @desc Get the maximum loop size String.\n     *\n     * @returns {String} result\n     *\n     */\n\n  }, {\n    key: '_getLoopMaxString',\n    value: function _getLoopMaxString() {\n      return this.loopMaxIterations ? ' ' + parseInt(this.loopMaxIterations) + '.0;\\n' : ' 1000.0;\\n';\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getConstantsString\n     *\n     * @desc Generate transpiled glsl Strings for constant parameters sent to a kernel\n     *\n     * They can be defined by *hardcodeConstants*\n     *\n     * @returns {String} result\n     *\n     */\n\n  }, {\n    key: '_getConstantsString',\n    value: function _getConstantsString() {\n      var result = [];\n      var threadDim = this.threadDim;\n      var texSize = this.texSize;\n\n      if (this.hardcodeConstants) {\n        result.push('ivec3 uOutputDim = ivec3(' + threadDim[0] + ',' + threadDim[1] + ', ' + threadDim[2] + ')', 'ivec2 uTexSize = ivec2(' + texSize[0] + ', ' + texSize[1] + ')');\n      } else {\n        result.push('uniform ivec3 uOutputDim', 'uniform ivec2 uTexSize');\n      }\n\n      return this._linesToString(result);\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getTextureCoordinate\n     *\n     * @desc Get texture coordinate string for the program\n     *\n     * @returns {String} result\n     *\n     */\n\n  }, {\n    key: '_getTextureCoordinate',\n    value: function _getTextureCoordinate() {\n      var names = this.subKernelOutputVariableNames;\n\n      if (names === null || names.length < 1) {\n        return 'varying vec2 vTexCoord;\\n';\n      } else {\n        return 'out vec2 vTexCoord;\\n';\n      }\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getDecode32EndiannessString\n     *\n     * @desc Get Decode32 endianness string for little-endian and big-endian\n     *\n     * @returns {String} result\n     *\n     */\n\n  }, {\n    key: '_getDecode32EndiannessString',\n    value: function _getDecode32EndiannessString() {\n      return this.endianness === 'LE' ? '' : '  rgba.rgba = rgba.abgr;\\n';\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getEncode32EndiannessString\n     *\n     * @desc Get Encode32 endianness string for little-endian and big-endian\n     *\n     * @returns {String} result\n     *\n     */\n\n  }, {\n    key: '_getEncode32EndiannessString',\n    value: function _getEncode32EndiannessString() {\n      return this.endianness === 'LE' ? '' : '  rgba.rgba = rgba.abgr;\\n';\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getDivideWithIntegerCheckString\n     *\n     * @desc if fixIntegerDivisionAccuracy provide method to replace /\n     *\n     * @returns {String} result\n     *\n     */\n\n  }, {\n    key: '_getDivideWithIntegerCheckString',\n    value: function _getDivideWithIntegerCheckString() {\n      return this.fixIntegerDivisionAccuracy ? '\\n\\t\\t\\t  float div_with_int_check(float x, float y) {\\n\\t\\t\\t  if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {\\n\\t\\t\\t    return float(int(x)/int(y));\\n\\t\\t\\t  }\\n\\t\\t\\t  return x / y;\\n\\t\\t\\t}\\n\\t\\t\\t' : '';\n    }\n    /**\n     * @function\n     * @memberOf WebGLKernel#\n     * @name _getGetWraparoundString\n     *\n     * @returns {String} wraparound string\n     */\n\n  }, {\n    key: '_getGetWraparoundString',\n    value: function _getGetWraparoundString() {\n      return this.wraparound ? '  xyz = mod(xyz, texDim);\\n' : '';\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getGetTextureChannelString\n     *\n     */\n\n  }, {\n    key: '_getGetTextureChannelString',\n    value: function _getGetTextureChannelString() {\n      if (!this.floatTextures) return '';\n      return this._linesToString(['  int channel = integerMod(index, 4)', '  index = index / 4']);\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getGetTextureIndexString\n     *\n     * @desc Get generic texture index string, if floatTextures flag is true.\n     *\n     * @example\n     * '  index = float(int(index)/4);\\n'\n     *\n     */\n\n  }, {\n    key: '_getGetTextureIndexString',\n    value: function _getGetTextureIndexString() {\n      return this.floatTextures ? '  index = index / 4;\\n' : '';\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getGetResultString\n     *\n     */\n\n  }, {\n    key: '_getGetResultString',\n    value: function _getGetResultString() {\n      if (!this.floatTextures) {\n        return '  return decode(texel, x, bitRatio);';\n      }\n\n      return this._linesToString(['  if (channel == 0) return texel.r', '  if (channel == 1) return texel.g', '  if (channel == 2) return texel.b', '  if (channel == 3) return texel.a']);\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getMainParamsString\n     *\n     * @desc Generate transpiled glsl Strings for user-defined parameters sent to a kernel\n     *\n     * @param {Array} args - The actual parameters sent to the Kernel\n     *\n     * @returns {String} result\n     *\n     */\n\n  }, {\n    key: '_getMainParamsString',\n    value: function _getMainParamsString(args) {\n      var result = [];\n      var paramTypes = this.paramTypes;\n      var paramNames = this.paramNames;\n\n      for (var i = 0; i < paramNames.length; i++) {\n        var param = args[i];\n        var paramName = paramNames[i];\n        var paramType = paramTypes[i];\n\n        if (this.hardcodeConstants) {\n          if (paramType === 'Array' || paramType === 'NumberTexture' || paramType === 'ArrayTexture(4)') {\n            var paramDim = utils.getDimensions(param, true);\n            var paramSize = utils.dimToTexSize({\n              floatTextures: this.floatTextures,\n              floatOutput: this.floatOutput\n            }, paramDim);\n            result.push('uniform sampler2D user_' + paramName, 'ivec2 user_' + paramName + 'Size = ivec2(' + paramSize[0] + ', ' + paramSize[1] + ')', 'ivec3 user_' + paramName + 'Dim = ivec3(' + paramDim[0] + ', ' + paramDim[1] + ', ' + paramDim[2] + ')', 'uniform int user_' + paramName + 'BitRatio');\n          } else if (paramType === 'Integer') {\n            result.push('float user_' + paramName + ' = ' + param + '.0');\n          } else if (paramType === 'Float') {\n            result.push('float user_' + paramName + ' = ' + param);\n          }\n        } else {\n          if (paramType === 'Array' || paramType === 'NumberTexture' || paramType === 'ArrayTexture(4)' || paramType === 'Input' || paramType === 'HTMLImage') {\n            result.push('uniform sampler2D user_' + paramName, 'uniform ivec2 user_' + paramName + 'Size', 'uniform ivec3 user_' + paramName + 'Dim');\n\n            if (paramType !== 'HTMLImage') {\n              result.push('uniform int user_' + paramName + 'BitRatio');\n            }\n          } else if (paramType === 'Integer' || paramType === 'Float') {\n            result.push('uniform float user_' + paramName);\n          } else {\n            throw new Error('Param type ' + paramType + ' not supported in WebGL, only WebGL2');\n          }\n        }\n      }\n\n      return this._linesToString(result);\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getMainConstantsString\n     *\n     */\n\n  }, {\n    key: '_getMainConstantsString',\n    value: function _getMainConstantsString() {\n      var result = [];\n\n      if (this.constants) {\n        for (var name in this.constants) {\n          if (!this.constants.hasOwnProperty(name)) continue;\n          var value = this.constants[name];\n          var type = utils.getArgumentType(value);\n\n          switch (type) {\n            case 'Integer':\n              result.push('const float constants_' + name + ' = ' + parseInt(value) + '.0');\n              break;\n\n            case 'Float':\n              result.push('const float constants_' + name + ' = ' + parseFloat(value));\n              break;\n\n            case 'Array':\n            case 'Input':\n            case 'HTMLImage':\n            case 'NumberTexture':\n            case 'ArrayTexture(4)':\n              result.push('uniform sampler2D constants_' + name, 'uniform ivec2 constants_' + name + 'Size', 'uniform ivec3 constants_' + name + 'Dim', 'uniform int constants_' + name + 'BitRatio');\n              break;\n\n            default:\n              throw new Error('Unsupported constant ' + name + ' type ' + type);\n          }\n        }\n      }\n\n      return this._linesToString(result);\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getKernelString\n     *\n     * @desc Get Kernel program string (in *glsl*) for a kernel.\n     *\n     * @returns {String} result\n     *\n     */\n\n  }, {\n    key: '_getKernelString',\n    value: function _getKernelString() {\n      var result = [];\n      var names = this.subKernelOutputVariableNames;\n\n      if (names !== null) {\n        result.push('float kernelResult = 0.0');\n\n        for (var i = 0; i < names.length; i++) {\n          result.push('float ' + names[i] + ' = 0.0');\n        }\n      } else {\n        result.push('float kernelResult = 0.0');\n      }\n\n      return this._linesToString(result) + this.functionBuilder.getPrototypeString('kernel');\n    }\n    /**\n     *\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getMainResultString\n     *\n     * @desc Get main result string with checks for floatOutput, graphical, subKernelsOutputs, etc.\n     *\n     * @returns {String} result\n     *\n     */\n\n  }, {\n    key: '_getMainResultString',\n    value: function _getMainResultString() {\n      var names = this.subKernelOutputVariableNames;\n      var result = [];\n\n      if (this.floatOutput) {\n        result.push('  index *= 4');\n      }\n\n      if (this.graphical) {\n        result.push('  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  gl_FragColor = actualColor');\n      } else if (this.floatOutput) {\n        var channels = ['r', 'g', 'b', 'a'];\n\n        for (var i = 0; i < channels.length; ++i) {\n          result.push('  threadId = indexTo3D(index, uOutputDim)');\n          result.push('  kernel()');\n\n          if (names) {\n            result.push('  gl_FragData[0].' + channels[i] + ' = kernelResult');\n\n            for (var j = 0; j < names.length; ++j) {\n              result.push('  gl_FragData[' + (j + 1) + '].' + channels[i] + ' = ' + names[j]);\n            }\n          } else {\n            result.push('  gl_FragColor.' + channels[i] + ' = kernelResult');\n          }\n\n          if (i < channels.length - 1) {\n            result.push('  index += 1');\n          }\n        }\n      } else if (names !== null) {\n        result.push('  threadId = indexTo3D(index, uOutputDim)');\n        result.push('  kernel()');\n        result.push('  gl_FragData[0] = encode32(kernelResult)');\n\n        for (var _i2 = 0; _i2 < names.length; _i2++) {\n          result.push('  gl_FragData[' + (_i2 + 1) + '] = encode32(' + names[_i2] + ')');\n        }\n      } else {\n        result.push('  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  gl_FragColor = encode32(kernelResult)');\n      }\n\n      return this._linesToString(result);\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _linesToString\n     *\n     * @param {Array} lines - An Array of strings\n     *\n     * @returns {String} Single combined String, seperated by *\\n*\n     *\n     */\n\n  }, {\n    key: '_linesToString',\n    value: function _linesToString(lines) {\n      if (lines.length > 0) {\n        return lines.join(';\\n') + ';\\n';\n      } else {\n        return '\\n';\n      }\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _replaceArtifacts\n     *\n     * @param {String} src - Shader string\n     * @param {Array} map - Variables/Constants associated with shader\n     *\n     */\n\n  }, {\n    key: '_replaceArtifacts',\n    value: function _replaceArtifacts(src, map) {\n      return src.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z])*)__;\\n/g, function (match, artifact) {\n        if (map.hasOwnProperty(artifact)) {\n          return map[artifact];\n        }\n\n        throw 'unhandled artifact ' + artifact;\n      });\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _addKernels\n     *\n     * @desc Adds all the sub-kernels supplied with this Kernel instance.\n     *\n     */\n\n  }, {\n    key: '_addKernels',\n    value: function _addKernels() {\n      var _this2 = this;\n\n      var builder = this.functionBuilder;\n      var gl = this._webGl;\n      builder.addFunctions(this.functions, {\n        constants: this.constants,\n        output: this.output\n      });\n      builder.addNativeFunctions(this.nativeFunctions);\n      builder.addKernel(this.fnString, {\n        prototypeOnly: false,\n        constants: this.constants,\n        output: this.output,\n        debug: this.debug,\n        loopMaxIterations: this.loopMaxIterations,\n        paramNames: this.paramNames,\n        paramTypes: this.paramTypes,\n        constantTypes: this.constantTypes,\n        fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy\n      });\n\n      if (this.subKernels !== null) {\n        var drawBuffers = this.drawBuffers = gl.getExtension('WEBGL_draw_buffers');\n        if (!drawBuffers) throw new Error('could not instantiate draw buffers extension');\n        this.subKernelOutputVariableNames = [];\n        this.subKernels.forEach(function (subKernel) {\n          return _this2._addSubKernel(subKernel);\n        });\n      } else if (this.subKernelProperties !== null) {\n        var _drawBuffers = this.drawBuffers = gl.getExtension('WEBGL_draw_buffers');\n\n        if (!_drawBuffers) throw new Error('could not instantiate draw buffers extension');\n        this.subKernelOutputVariableNames = [];\n        Object.keys(this.subKernelProperties).forEach(function (property) {\n          return _this2._addSubKernel(_this2.subKernelProperties[property]);\n        });\n      }\n    }\n  }, {\n    key: '_addSubKernel',\n    value: function _addSubKernel(subKernel) {\n      this.functionBuilder.addSubKernel(subKernel, {\n        prototypeOnly: false,\n        constants: this.constants,\n        output: this.output,\n        debug: this.debug,\n        loopMaxIterations: this.loopMaxIterations,\n        fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy\n      });\n      this.subKernelOutputVariableNames.push(subKernel.name + 'Result');\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getFragShaderString\n     *\n     * @desc Get the fragment shader String.\n     * If the String hasn't been compiled yet,\n     * then this method compiles it as well\n     *\n     * @param {Array} args - The actual parameters sent to the Kernel\n     *\n     * @returns {string} Fragment Shader string\n     *\n     */\n\n  }, {\n    key: '_getFragShaderString',\n    value: function _getFragShaderString(args) {\n      if (this.compiledFragShaderString !== null) {\n        return this.compiledFragShaderString;\n      }\n\n      return this.compiledFragShaderString = this._replaceArtifacts(this.constructor.fragShaderString, this._getFragShaderArtifactMap(args));\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name _getVertShaderString\n     *\n     * @desc Get the vertical shader String\n     *\n     * @param {Array} args - The actual parameters sent to the Kernel\n     *\n     * @returns {string} Vertical Shader string\n     *\n     */\n\n  }, {\n    key: '_getVertShaderString',\n    value: function _getVertShaderString(args) {\n      if (this.compiledVertShaderString !== null) {\n        return this.compiledVertShaderString;\n      }\n\n      return this.compiledVertShaderString = this.constructor.vertShaderString;\n    }\n    /**\n     * @memberOf WebGLKernel#\n     * @function\n     * @name toString\n     *\n     * @desc Returns the *pre-compiled* Kernel as a JS Object String, that can be reused.\n     *\n     */\n\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return kernelString(this);\n    }\n  }, {\n    key: 'addFunction',\n    value: function addFunction(fn) {\n      this.functionBuilder.addFunction(null, fn);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy(removeCanvasReferences) {\n      _get(WebGLKernel.prototype.__proto__ || Object.getPrototypeOf(WebGLKernel.prototype), 'destroy', this).call(this);\n\n      if (this.outputTexture) {\n        this._webGl.deleteTexture(this.outputTexture);\n      }\n\n      if (this.buffer) {\n        this._webGl.deleteBuffer(this.buffer);\n      }\n\n      if (this.framebuffer) {\n        this._webGl.deleteFramebuffer(this.framebuffer);\n      }\n\n      if (this.vertShader) {\n        this._webGl.deleteShader(this.vertShader);\n      }\n\n      if (this.fragShader) {\n        this._webGl.deleteShader(this.fragShader);\n      }\n\n      if (this.program) {\n        this._webGl.deleteProgram(this.program);\n      }\n\n      var keys = Object.keys(this.textureCache);\n\n      for (var i = 0; i < keys.length; i++) {\n        var name = keys[i];\n\n        this._webGl.deleteTexture(this.textureCache[name]);\n      }\n\n      if (this.subKernelOutputTextures) {\n        for (var _i3 = 0; _i3 < this.subKernelOutputTextures.length; _i3++) {\n          this._webGl.deleteTexture(this.subKernelOutputTextures[_i3]);\n        }\n      }\n\n      if (removeCanvasReferences) {\n        var idx = canvases.indexOf(this._canvas);\n\n        if (idx >= 0) {\n          canvases[idx] = null;\n          maxTexSizes[idx] = null;\n        }\n      }\n\n      delete this._webGl;\n    }\n  }]);\n\n  return WebGLKernel;\n}(KernelBase);","map":null,"metadata":{},"sourceType":"script"}